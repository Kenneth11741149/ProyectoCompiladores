package codigo;

import java_cup.runtime.Symbol;
import java.io.FileWriter;
import java.io.IOException;
parser code
{:
    private Symbol s;
    Node raiz;
    public void syntax_error(Symbol s){
        this.s = s;
        String error = "";
        if(s.value != null){
            error = "Error Sintactico en la linea "+s.right+ " Columna "+(s.left+1)+ ". No se esperaba esto: "+ "\""+ s.value+ "\""+ "\n" ;
            try {
                FileWriter myWriter = new FileWriter("errors.txt",true);
                myWriter.append(error);
            
                myWriter.close();
            
            } catch (IOException e) {
            System.out.println("An error occurred.");
            e.printStackTrace();
             }
             
           System.out.print(error);
        }
        //errores.add(error)
    }
    
    protected int error_sync_size(){
        return 2;
    }
    


    public Symbol getS(){
        return this.s;
    }
:};

terminal Linea, Comillas,Caracter, T_dato, Int,Character,OpenTest,CloseTest,Or,Then,OpenUntil,CloseUntil,Do,OpenFor,CloseFor,
    Igual, Suma, Resta, Multiplicacion, Division, Op_logico, Op_relacional,Return,
    Op_atribucion, Op_incremento, Op_booleano, Parentesis_a, Parentesis_c,OpenMethod,CloseMethod,
    Llave_a, Llave_c, Corchete_a, Corchete_c, Main, P_coma, Identificador,Coma,
    Numero, ERROR,CloseMain,As,Define,L,Boolean,Eat,Throwln,THrow,OpenMatch,CloseMatch,When,Stop,AND,OR,NOT,STRING;
non terminal INICIO, SENTENCIA, DECLARACION, DECLARACION_FOR, IF, IF_ELSE,
    UNTIL,FOR, SENTENCIA_BOOLEANA, SENTENCIA_FOR,LECTURA,ESCRITURA,MATCH,CASE,Identificadoroletra,METHOD,CALLMETHOD,LISTABOOL,EXP,E,T,F,PARAMETROS,PARAMETROS2,LEXE,
    TYPM, TYPV;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left NOT;


start with INICIO;

INICIO ::= 

    Main Parentesis_a Parentesis_c SENTENCIA:h2 CloseMain
         {: 
           raiz = new Node("ROOT",false);
           Node x = new Node("MAIN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
            }
           //x.addHijo((Node)h2);
           raiz.addHijo(x);
           System.out.println(raiz.Imprimir(0)); 
          
          
          
        :} 
    |
    Main Parentesis_a Parentesis_c SENTENCIA:h2 CloseMain METHOD:h3
    {: 
           raiz = new Node("ROOT",false);
           
           Node x = new Node("MAIN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
            }
           //x.addHijo((Node)h2);
           raiz.addHijo(x);
           for(int i = 0;i<((Node)h3).getHijos().size();i++){
                raiz.addHijo(((Node)h3).getHijos().get(i));
            }
           
           System.out.println(raiz.Imprimir(0));
           
          
          
        :} 

        |Main Parentesis_a Parentesis_c CloseMain METHOD:h3
        {:
         raiz = new Node("ROOT",false);
           
           Node x = new Node("MAIN",false);
           raiz.addHijo(x);
           for(int i = 0;i<((Node)h3).getHijos().size();i++){
                raiz.addHijo(((Node)h3).getHijos().get(i));
            }
           
           System.out.println(raiz.Imprimir(0));
        :}
///////////////////////////////////////////////////////////////////////////////////////////////////////

    | Main Parentesis_a Parentesis_c error CloseMain 
        {: //System.out.println("Main() Error CloseMain. Hay presencia de errores en el cuerpo de sentencia del main.");
            parser.syntax_error(new Symbol(sym.error,0,0,"[1] Hay presencia de errores en el cuerpo de sentencia del main.")); 
         :}
    | error SENTENCIA CloseMain
        {: //System.out.println("Error SENTENCIA CloseMain");  
        parser.syntax_error(new Symbol(sym.error,0,0,"[2] Problema en la declaracion del main."));
        :} //Todo error desde el inicio hasta alguna sentencia.
                                                              //Error en la declaracion del main.
    | error CloseMain
      {: //System.out.println("Error CloseMain");  
         parser.syntax_error(new Symbol(sym.error,0,0,"[3] Error en la declaracion del main."));
      :} //Todo error que venga desde el inicio hasta el CloseMain es cubierto.
                                                    //Error en la declaracion de un main vacio.

    | Main Parentesis_a Parentesis_c error CloseMain METHOD
        {: //System.out.println("Main() Error CloseMain. Hay presencia de errores en el cuerpo de sentencia del main.");
            parser.syntax_error(new Symbol(sym.error,0,0,"[4] Hay presencia de valores lexicos no reconocidos en el cuerpo de sentencia del main.")); 
         :}
    | error SENTENCIA CloseMain METHOD
        {: //System.out.println("Error SENTENCIA CloseMain");  
        parser.syntax_error(new Symbol(sym.error,0,0,"[5] Problema en la declaracion del main."));
        :} //Todo error desde el inicio hasta alguna sentencia.
                                                              //Error en la declaracion del main.
    | error CloseMain METHOD
      {: //System.out.println("Error CloseMain");  
         parser.syntax_error(new Symbol(sym.error,0,0,"[6] Error en la declaracion del main."));
      :} //Todo error que venga desde el inicio hasta el CloseMain es cubierto.
    
    
    | error
      {:// System.out.println("");  
        parser.syntax_error(new Symbol(sym.error,0,0,"[7] No se reconoce el valor ingresado. No se encontro un main."));
      :} //Todo error que no se recupere
                                                                          //Unrecognized code.

    | Main error
      {: //System.out.println("Main Error");  
         parser.syntax_error(new Symbol(sym.error,0,0,"[8] el cuerpo del main presenta errores."));
      :} 
                                                                          //Unrecognized code.
    | {: 
        parser.syntax_error(new Symbol(sym.error,0,0,"[9] No hay codigo para analizar. No hay un main."));
      :} //No hay codigo para

    

;

LEXE ::= ERROR:h1 {:
     
         
         try {
                FileWriter myWriter = new FileWriter("errors.txt",true);
                myWriter.append("ERROR LEXICO: "+h1.toString());
            
                myWriter.close();
            
            } catch (IOException e) {
            System.out.println("An error occurred.");
            e.printStackTrace();
             }
           
        
:}
;


SENTENCIA ::= 
    SENTENCIA:h1 DECLARACION:h2
        {:
           
           Node x = new Node("SENTENCIA",false);
           for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
           x.addHijo((Node)h2);
           RESULT = x; 
    :}
     |
    DECLARACION:h2
        {: Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
            :}
     |
    SENTENCIA:h1 IF:h2
           {:
           Node x = new Node("SENTENCIA",false);
            for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
           x.addHijo((Node)h2);
           RESULT = x; 
    :}
     | 
    IF:h2
        {:  Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
            :}
     |
    SENTENCIA:h1 IF_ELSE:h2
            {:
                Node x = new Node("SENTENCIA",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                x.addHijo((Node)h2);
                RESULT = x; 
            :}
        
     |
    IF_ELSE:h2 
    {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :} |
    SENTENCIA:h1 UNTIL:h2
    {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
               
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    UNTIL:h2
         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
     |
    SENTENCIA:h1 FOR:h2
     {:
                Node x = new Node("SENTENCIA",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
               
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
     |
    FOR:h2
            {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    
     |
    SENTENCIA:h1 LECTURA:h2
       {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    LECTURA:h2
            {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    |
    SENTENCIA:h1 ESCRITURA:h2
               {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    ESCRITURA:h2
           {:
            Node x = new Node("SENTENCIA",false);
            
            x.addHijo((Node)h2);
            RESULT = x;
    :}
        
    |
    SENTENCIA:h1 MATCH:h2
              {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}     
    |
    MATCH:h2

         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    | SENTENCIA:h1 CALLMETHOD:h2
    {:
        Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    CALLMETHOD:h2

         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    
    
;

PARAMETROS2::= Identificadoroletra:h1{:
           Node raiz = new Node("PARAMETROS",false);
           Node idoletra = (Node)h1;
           idoletra.setType("VARIABLE");
           //raiz.addHijo((Node)h1);
           raiz.addHijo(idoletra);
           RESULT = raiz;
           :}

        |  Numero:h1{:
           Node raiz = new Node("PARAMETROS",false);
           Node x = new Node(h1.toString(),false);
           x.setType("integer");
           raiz.addHijo(x);
           RESULT = raiz;
           :}

        |
        PARAMETROS2:h1 P_coma Identificadoroletra:h2
        {:
        Node raiz = new Node("PARAMETROS",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
           Node idoletra = (Node)h2;
           idoletra.setType("VARIABLE");
           //raiz.addHijo((Node)h2);
           raiz.addHijo(idoletra);
           RESULT = raiz;
:}
    |
        PARAMETROS2:h1 P_coma Numero:h2
        {:
        Node raiz = new Node("PARAMETROS",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
           Node x = new Node(h2.toString(),false);
           x.setType("integer");
           raiz.addHijo(x);
           RESULT = raiz;
:}

|{:
    Node raiz = new Node("PARAMETROS",false);
    RESULT = raiz;
:}
;

//NEED TO EDIT THIS ONE TOO
PARAMETROS::=  TYPV:t Identificadoroletra:h1{:
           Node raiz = new Node("PARAMETRO",false);
           raiz.addHijo(new Node(t.toString(),false));
           raiz.addHijo((Node)h1);
           RESULT = raiz;
           :}
        |
        PARAMETROS:h1 P_coma TYPV:t Identificadoroletra:h2
        {:
        Node raiz = new Node("PARAMETROS",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
        raiz.addHijo(new Node(t.toString(),false));
           raiz.addHijo((Node)h2);
           RESULT = raiz;
:}
;
EXP ::= E:e 
{: RESULT = e;  :}
;

E ::=   E:e Suma T:t {: 
        Node x = new Node("+",false);
        x.addHijo((Node)e);
        x.addHijo((Node)t);
        RESULT = x;  :}
        |
        E:e Resta T:t {: 
        Node x = new Node("-",false);
        x.addHijo((Node)e);
        x.addHijo((Node)t);
        RESULT = x;  :}
        |
        T:t{:
            RESULT = t;
        :}
        

;

T ::=  T:t Multiplicacion F:f{:
        Node x = new Node("*",false);
        x.addHijo((Node)t);
        x.addHijo((Node)f);
        RESULT = x;
        :} 
        |
        T:t Division F:f{:
        Node x = new Node("/",false);
        x.addHijo((Node)t);
        x.addHijo((Node)f);
        RESULT = x;
        :}
        |
        F:f {:
        RESULT = f;
        :}
;

F ::=   Numero:h1{:
            Node x = new Node(h1.toString(),false);
            x.setType("integer"); //Kenneth Approved data-type.
            RESULT = x;
            :}
        |
        Identificadoroletra:h1{:
        Node x = (Node)h1;
        x.setType("VARIABLE"); //Kenneth Approved data-type.
        RESULT = x;
        :}
        |Parentesis_a E:e Parentesis_c{:
            RESULT = e;
        :}
        
;


METHOD ::=
    OpenMethod TYPM:t Identificadoroletra:h1 Parentesis_a Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        String xt = t.toString();
        Node x = new Node(xt,false);
        //Node x = Node(t);
        x.addHijo((Node)h1);
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT =  raiz; 
    :}

    |
    OpenMethod TYPM:t Identificadoroletra:h1 Parentesis_a PARAMETROS:params Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
       String xt = t.toString();
        Node x = new Node(xt,false);
        
        x.addHijo((Node)h1);
        /*
        Node parms = new Node("PARAMS" , false);
        for(int i = 0;i<((Node)params).getHijos().size();i++){
                parms.addHijo(((Node)params).getHijos().get(i));
            }
        x.addHijo(parms);
        
        for(int i = 0;i<((Node)params).getHijos().size();i++){
            Node parx = new Node("PARAMETRO", false);
            parx.addHijo(((Node)params).getHijos());
            x.addHijo(parx);
          }
        */
        x.addHijo(((Node)params));
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT =  raiz; 
    :}
    
    |
     METHOD:m1 OpenMethod TYPM:t Identificadoroletra:h1 Parentesis_a  Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        for(int i = 0;i<((Node)m1).getHijos().size();i++){
                raiz.addHijo(((Node)m1).getHijos().get(i));
            }
        String xt = t.toString();
        Node x = new Node(xt,false);
        x.addHijo((Node)h1);
        
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT = raiz; 
    :}
    |
    METHOD:m1 OpenMethod TYPM:t Identificadoroletra:h1 Parentesis_a PARAMETROS:params Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        for(int i = 0;i<((Node)m1).getHijos().size();i++){
                raiz.addHijo(((Node)m1).getHijos().get(i));
            }
        String xt = t.toString();
        Node x = new Node(xt,false);
        x.addHijo((Node)h1);
        
        /*
        Node parms = new Node("PARAMS" , false);
        for(int i = 0;i<((Node)params).getHijos().size();i++){
                parms.addHijo(((Node)params).getHijos().get(i));
            }
            
          for(int i = 0;i<((Node)params).getHijos().size();i++){
            Node parx = new Node("PARAMETRO", false);
            parx.addHijo(((Node)params).getHijos());
            x.addHijo(parx);
          }
          */
        x.addHijo((Node)params);
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT = raiz; 
    :}
    | OpenMethod error CloseMethod
    {:
    System.out.println("Error en el cuerpo de la funcion");
    :}
    | METHOD:m1 OpenMethod error CloseMethod
    {:
    System.out.println("Error en el cuerpo de la funcion");
    :}

;

TYPM ::= Boolean {:
      String RetVal = "BOOLEAN METHOD";
      RESULT = RetVal;
    :}
    | 
    Character {:
      String RetVal = "CHARACTER METHOD";
      RESULT = RetVal;
    :}|
    Int {:
      String RetVal = "INT METHOD";
      RESULT = RetVal;
    :}
;

TYPV ::= Boolean {:
      String RetVal = "boolean";
      RESULT = RetVal;
    :}
    | 
    Character {:
      String RetVal = "character";
      RESULT = RetVal;
    :}|
    Int {:
      String RetVal = "integer";
      RESULT = RetVal;
    :}
;


Identificadoroletra ::= 
    Identificador:h1
         {:  Node x = new Node(h1.toString(),false);
            x.setType("ID");
            RESULT = x;
            :}
    |
    L:h1
    {:  Node x = new Node(h1.toString(),false);
            x.setType("char");
            RESULT = x;
            :}
;





CALLMETHOD ::=
    Identificadoroletra:h1 Parentesis_a PARAMETROS2:h2 Parentesis_c P_coma
    {:
    Node x = new Node("METHOD-CALL",true);
    x.addHijo((Node)h1);
    x.addHijo((Node)h2);
    RESULT = x;
    :}

    ///////////////////////////////
    //Error handling block
    ///////////////////////////////

    |   Identificadoroletra:h1 Parentesis_a PARAMETROS2:h2 Parentesis_c:erp
       {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[23] Declaracion de callmethod sin PComa"));
       :}
;





DECLARACION ::= 
    //Int
    Define Identificadoroletra:h2 As Int P_coma
         {: 
        Node x = new Node("DECLARATION",false);
        Node x2 = new Node("integer",false);
        x2.setType("integer");
        x.addHijo(x2);
        x.addHijo((Node)h2);
        RESULT = x;
        :} 
    |
     
     Define Identificadoroletra:h2 As Int Igual EXP:h1 P_coma
        {: 
        Node x = new Node("DECLARATION",false);
        Node x2 = new Node("integer",false);
       
        x.addHijo(x2);
        x.addHijo((Node)h2);
        x.addHijo((Node)h1);
        RESULT = x;
        :} 
    |
    Identificadoroletra:h1 Igual EXP:h2 P_coma
        {:
        Node x = new Node("ASSIGNMENT",false);
        x.addHijo((Node)h1);
        x.addHijo((Node)h2);
        RESULT = x;
        :}
    
    |
    Identificadoroletra:h1 Igual CALLMETHOD:h2  
        {:
        Node x = new Node("ASSIGNMENT",false);
        x.addHijo((Node)h1);
        Node Callmethod = (Node)h2;
        Callmethod.setType("METHOD-CALL");
        x.addHijo((Node)h2);
        RESULT = x;
        :}
    |
        Identificadoroletra:h1 Igual Op_booleano:b1 P_coma
        {:
        Node x = new Node("ASSIGNMENT",false);
        x.addHijo((Node)h1);
        Node x2 = new Node(b1.toString(),false);
        x.addHijo((Node)x2);
        RESULT = x;
        :}
    |   //new addition id := varchar[num];
        Identificadoroletra:h1 Igual Identificadoroletra:h2 Corchete_a Numero:n Corchete_c P_coma
        {:
        Node x = new Node("ASSIGNMENT DE ARRAY",false);
        x.addHijo((Node)h1);
        Node x2 = new Node(n.toString(),false);
        Node x3 = (Node) h2;
        x3.addHijo(x2);
        x.addHijo(x3);
        RESULT = x;
        :}
    |
        //new addition id := varchar[num][num]
        Identificadoroletra:h1 Igual Identificadoroletra:h2 Corchete_a Numero:n Corchete_c  Corchete_a Numero:n2 Corchete_c P_coma
        {:
        Node x = new Node("ASSIGNMENT DE MATRIX",false);
        x.addHijo((Node)h1);
        Node x2 = new Node(n.toString(),false);
        Node x3 = new Node(n2.toString(),false);
        Node x4 = (Node) h2;
        x4.addHijo(x2);
        x4.addHijo(x3);
        x.addHijo(x4);
        RESULT = x;
        :}
    |
    //new addition  id := varchar[id]
        Identificadoroletra:h1 Igual Identificadoroletra:h2 Corchete_a Identificadoroletra:h3 Corchete_c P_coma
        {:
        Node x = new Node("ASSIGNMENT DE ARRAY",false);
        x.addHijo((Node)h1);
        Node x2 = (Node) h2;
        x2.addHijo((Node)h3);
        x.addHijo(x2);
        RESULT = x;
        :}
    |
        //new addition  id := varchar[id][id]
        Identificadoroletra:h1 Igual Identificadoroletra:h2 Corchete_a Identificadoroletra:h3 Corchete_c  Corchete_a Identificadoroletra:h4 Corchete_c P_coma
        {:
        Node x = new Node("ASSIGNMENT DE MATRIX",false);
        x.addHijo((Node)h1);
      
        Node x2 = (Node) h2;
        x2.addHijo((Node)h3);
        x2.addHijo((Node)h4);
        x.addHijo(x2);
        RESULT = x;
        :}
    |
    
    Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Igual Caracter:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT ARRAY",false);
                x.addHijo((Node)h1);
                Node corchetes = new Node(n.toString(),false);
                corchetes.addHijo(new Node(h2.toString(),false));
                x.addHijo(corchetes);
                RESULT = x;
            :}
    | Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Igual Numero:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT ARRAY",false);
                x.addHijo((Node)h1);
                Node corchetes = new Node(n.toString(),false);
                corchetes.addHijo(new Node(h2.toString(),false));
                x.addHijo(corchetes);
                RESULT = x;
            :}        
   
    |Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Igual  Identificadoroletra:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT ARRAY",false);
                x.addHijo((Node)h1);
                Node corchetes = new Node(n.toString(),false);
                corchetes.addHijo((Node)h2);
                x.addHijo(corchetes);
                RESULT = x;
            :}

    | //new addition array[num] := callmethod
    Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Igual  CALLMETHOD:h2
            {:
             Node x = new Node("ASSIGNMENT ARRAY",false);
                x.addHijo((Node)h1);
                Node corchetes = new Node(n.toString(),false);
                Node Callmethod = (Node)h2;
                Callmethod.setType("METHOD-CALL");
                corchetes.addHijo((Node)h2);
                x.addHijo(corchetes);
                RESULT = x;
            :}

    | 
    //new addition array[id] := callmethod
    Identificadoroletra:h1 Corchete_a Identificadoroletra:c1 Corchete_c Igual  CALLMETHOD:h2
            {:
             Node x = new Node("ASSIGNMENT ARRAY",false);
                x.addHijo((Node)h1);
                Node corchetes = (Node) c1;
                Node Callmethod = (Node)h2;
                Callmethod.setType("METHOD-CALL");
                corchetes.addHijo((Node)h2);
                x.addHijo(corchetes);
                RESULT = x;
            :}

    | 
    //new addition array[id] := char
    Identificadoroletra:h1 Corchete_a Identificadoroletra:h2 Corchete_c Igual Caracter:h3 P_coma
            {:
             Node x = new Node("ASSIGNMENT ARRAY",false);
                x.addHijo((Node)h1);
                Node corchetes = (Node)h2;
                corchetes.addHijo(new Node(h3.toString(),false));
                x.addHijo(corchetes);
                RESULT = x;
            :}
    | 
       //new addition array[id] := num
    Identificadoroletra:h1 Corchete_a Identificadoroletra:h2 Corchete_c Igual Numero:h3 P_coma
            {:
             Node x = new Node("ASSIGNMENT ARRAY",false);
                x.addHijo((Node)h1);
                Node corchetes = (Node)h2;
                corchetes.addHijo(new Node(h3.toString(),false));
                x.addHijo(corchetes);
                RESULT = x;
            :}        
   
    |//new addition array[id] := id
    Identificadoroletra:h1 Corchete_a Identificadoroletra:h2 Corchete_c Igual  Identificadoroletra:h3 P_coma
            {:
             Node x = new Node("ASSIGNMENT ARRAY",false);
                x.addHijo((Node)h1);
                Node corchetes = (Node)h2;
                corchetes.addHijo((Node)h3);
                x.addHijo(corchetes);
                RESULT = x;
            :}

    |
    Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Corchete_a Numero:n2 Corchete_c Igual  Identificadoroletra:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT MATRIX",false);
                x.addHijo((Node)h1);
                Node corchetes = new Node(n.toString(),false);
                Node corchetes2 = new Node(n2.toString(),false);
                corchetes2.addHijo((Node)h2);
                x.addHijo(corchetes);
                x.addHijo(corchetes2);
                RESULT = x;
            :}
        
    |Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Corchete_a Numero:n2 Corchete_c Igual  Caracter:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT MATRIX",false);
                x.addHijo((Node)h1);
                Node corchetes = new Node(n.toString(),false);
                Node corchetes2 = new Node(n2.toString(),false);
                corchetes2.addHijo(new Node(h2.toString(),false));
                x.addHijo(corchetes);
                x.addHijo(corchetes2);
                RESULT = x;
            :}

    |Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Corchete_a Numero:n2 Corchete_c Igual  Numero:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT MATRIX",false);
                x.addHijo((Node)h1);
                Node corchetes = new Node(n.toString(),false);
                Node corchetes2 = new Node(n2.toString(),false);
                corchetes2.addHijo(new Node(h2.toString(),false));
                x.addHijo(corchetes);
                x.addHijo(corchetes2);
                RESULT = x;
            :}

    |   //NEW ADDITION id[num][num] := methodcall;
        Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Corchete_a Numero:n2 Corchete_c Igual  CALLMETHOD:h2  
            {:
             Node x = new Node("ASSIGNMENT MATRIX",false);
                x.addHijo((Node)h1);
                Node corchetes = new Node(n.toString(),false);
                Node corchetes2 = new Node(n2.toString(),false);
                Node Callmethod = (Node)h2;
                Callmethod.setType("METHOD-CALL");
                corchetes2.addHijo((Node)h2);
                x.addHijo(corchetes);
                x.addHijo(corchetes2);
                RESULT = x;
            :}
    |
    // NEW ADDITION id[id][id] := id;
    Identificadoroletra:h1 Corchete_a Identificadoroletra:c1 Corchete_c Corchete_a Identificadoroletra:c2 Corchete_c Igual  Identificadoroletra:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT MATRIX",false);
                x.addHijo((Node)h1);
                Node corchetes = (Node)c1;
                Node corchetes2 = (Node)c2;
                corchetes2.addHijo((Node)h2);
                x.addHijo(corchetes);
                x.addHijo(corchetes2);
                RESULT = x;
            :}
        
    |
    //NEW ADDITION id[id][id] := char;
    Identificadoroletra:h1 Corchete_a Identificadoroletra:c1 Corchete_c Corchete_a Identificadoroletra:c2 Corchete_c Igual  Caracter:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT MATRIX",false);
                x.addHijo((Node)h1);
                Node corchetes = (Node)c1;
                Node corchetes2 = (Node)c2;
                corchetes2.addHijo(new Node(h2.toString(),false));
                x.addHijo(corchetes);
                x.addHijo(corchetes2);
                RESULT = x;
            :}

    |
        //NEW ADDITON id[id][id] := num;
        Identificadoroletra:h1 Corchete_a Identificadoroletra:c1 Corchete_c Corchete_a Identificadoroletra:c2 Corchete_c Igual  Numero:h2 P_coma
            {:
             Node x = new Node("ASSIGNMENT MATRIX",false);
                x.addHijo((Node)h1);
                Node corchetes = (Node)c1;
                Node corchetes2 = (Node)c2;
                corchetes2.addHijo(new Node(h2.toString(),false));
                x.addHijo(corchetes);
                x.addHijo(corchetes2);
                RESULT = x;
            :}
    |
        //NEW ADDITION id[id][id] := methodcall;
        Identificadoroletra:h1 Corchete_a Identificadoroletra:c1 Corchete_c Corchete_a Identificadoroletra:c2 Corchete_c Igual  CALLMETHOD:h2
            {:
             Node x = new Node("ASSIGNMENT MATRIX",false);
                x.addHijo((Node)h1);
                Node corchetes = (Node)c1;
                Node corchetes2 = (Node)c2;
                Node Callmethod = (Node)h2;
                Callmethod.setType("METHOD-CALL");
                corchetes2.addHijo((Node)h2);
                x.addHijo(corchetes);
                x.addHijo(corchetes2);
                RESULT = x;
            :}
    |

    

    // int array
    Define Identificadoroletra:h1 As Int Corchete_a Numero:n Corchete_c P_coma
        {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("integer array",false);
                Node x4 = new Node(n.toString(),false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |
    // int matriz
    Define Identificadoroletra:h1 As Int Corchete_a Numero:n1 Corchete_c Corchete_a Numero:n2 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("integer matrix",false);
                Node x4 = new Node(n1.toString(),false);
                Node x5 = new Node(n2.toString(),false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                x.addHijo(x5);
                RESULT = x;
        
        :}
    |
     /* int array NEW ADDITON
    Define Identificadoroletra:h1 As Int Corchete_a Identificadoroletra:h2 Corchete_c P_coma
        {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("integer array",false);
                
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo((Node)h2);
                RESULT = x;
        
        :}
    |
    // int matriz NEW ADDITON
    Define Identificadoroletra:h1 As Int Corchete_a Identificadoroletra:h2 Corchete_c Corchete_a Identificadoroletra:h3 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("integer matrix",false);
               
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo((Node)h2);
                x.addHijo((Node)h3);
                RESULT = x;
        
        :}
    |*/

    

   
    //Deprecated
    //Define L As Int P_coma|  
    //Define L As Int Igual Numero P_coma|
    


    //Char
    Define Identificadoroletra:h1 As Character P_coma
        {: 
            Node x = new Node("DECLARATION",false);
            Node x2 = new Node("character",false);
            x.addHijo(x2);
            x.addHijo((Node)h1);
            RESULT = x;
        :} 
    |
    Define Identificadoroletra:h1 As Character Igual Caracter:c1 P_coma
          {: 
            Node x = new Node("DECLARATION",false);
            Node x2 = new Node("character",false);
            Node x3 = new Node(c1.toString(),false);
            x.addHijo(x2);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            RESULT = x;
        :} 
    |
    
     // char array
    Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("character array",false);
                Node x4 = new Node(c1.toString(),false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |
    // char matriz
    Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c Corchete_a Numero:c2 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("character matrix",false);
                Node x4 = new Node("["+c1.toString()+"]"+"["+c2.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    
    |


    //Deprecated
    //Define L As Character P_coma|
    //Define L As Character Igual Comillas Identificador Comillas P_coma|

    //boolean
    Define Identificadoroletra:h1 As Boolean P_coma
            {: 
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("boolean",false);
               
                x.addHijo(x2);
                x.addHijo((Node)h1);
                RESULT = x;
        :} 
    |
    Define Identificadoroletra:h1 As Boolean Igual Op_booleano:b1 P_coma
          {: 
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("boolean",false);
                
                Node x4 = new Node(b1.toString(),false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        :} 
    
    
    //Deprecated
    //Define L As Boolean P_coma|
    //Define L As Boolean Igual Op_booleano P_coma|

    /* ERROR HANDLING BLOCK FOR DECLARATIONS*/
    | error P_coma
    {: System.out.println("[1] error en Declaracion de sentencia"); :} //hubo un error en la declaracion de variable.
    | error DECLARACION
    {: System.out.println("[2] error en DECLARACION"); :} //hubo un error en la declaracion de variable. se recupero con otra expresion
    | error IF_ELSE
    {: System.out.println("[3] error en Declaracion"); :} //hubo un error en la declaracion de variable.
    | error UNTIL
    {: System.out.println("[4] error en Declaracion"); :} //hubo un error en la declaracion de variable.
    | error CloseMain
    {: System.out.println("[5] error en Declaracion"); :} //hubo un error en la declaracion de variable.\
    | error IF
    {: System.out.println("[6] error en Declaracion"); :} //hubo un error en la declaracion de variable.
    | error FOR
    {: System.out.println("[7] error ne Declaracion"); :} //hubo un error en la declaracion de variable.
    |  Define Identificadoroletra As Int:erp
        {: // System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[8] Declaracion sin PComa"));
        :}
    |  Define Identificadoroletra As Int Igual EXP:erp
        {: //System.out.println("error NO PCOMA EXP ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[9] Declaracion sin PComa"));
        :}
    |  Identificadoroletra Igual EXP:erp
        {: //System.out.println("error NO PCOMA EXP ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[10] Asignacion sin Punto y Coma"));
        :}
    /*|  Identificadoroletra Igual CALLMETHOD:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright," Asignacion sin punto y coma."));
        :}*/
    |  Define Identificadoroletra:h1 As Int Corchete_a Numero:n Corchete_c:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[11] Declaracion sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Int Corchete_a Numero:n1 Corchete_c Corchete_a Numero:n2 Corchete_c:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[12] Declaracion sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Character:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[13] Declaracion sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Character Igual Caracter:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[14] Declaracion sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[15] Declaracion sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c Corchete_a Numero:c2 Corchete_c:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[16] Declaracion sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Boolean:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[17] Declaracion sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Boolean Igual Op_booleano:erp
        {: //System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[18] Declaracion sin PComa"));
        :}
    /*|  Identificadoroletra Igual EXP:erp
        {: //System.out.println("error NO PCOMA EXP ISSUE"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra As:erp
        {: //System.out.println("error NO PCOMA EXP ISSUE"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[19] Problema en Declaracion"));
        :}
    |  Define Identificadoroletra:erp
        {: // System.out.println("error NO PCOMA EXP ISSUE"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[20] Problema en Declaracion"));
        :}*/
    /*| error Identificador:erp
          {: //System.out.println("error NO PCOMA EXP ISSUE NEW"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"lol"));
        :}
    | error As
        {: //System.out.println("error NO PCOMA EXP ISSUE NEW2"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"[21] Problema en Declaracion"));
        :}
    | error Igual
        {: //System.out.println("error NO PCOMA EXP ISSUE NEW3"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"[22] Problema en Declaracion"));
        :}*/





     |   Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Igual Caracter:erp
            {:
             parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[23] Declaracion sin PComa"));
            :}
    | Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Igual Numero:erp
            {:
             parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[24] Declaracion sin PComa"));
            :}        
   
    |Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Igual  Identificadoroletra:erp
            {:
             parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[25] Declaracion sin PComa"));
            :}

    | Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Corchete_a Numero:n2 Corchete_c Igual  Identificadoroletra:erp
            {:
             parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[26] Declaracion sin PComa"));
            :}
        
    |Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Corchete_a Numero:n2 Corchete_c Igual  Caracter:erp
            {:
            parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[27] Declaracion sin PComa"));
            :}

    |Identificadoroletra:h1 Corchete_a Numero:n Corchete_c Corchete_a Numero:n2 Corchete_c Igual  Numero:erp
            {:
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[28] Declaracion sin PComa"));
            :}

















        
;


IF ::= OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then SENTENCIA:h2 CloseTest
         {: 
           Node x = new Node("TEST",false);
           Node x2 = new Node("THEN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
           }
           for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        x.addHijo(((Node)h1).getHijos().get(i));
           }
           
           x.addHijo(x2);
           RESULT = x;
            
           
        :} 
        
        
        | OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then CloseTest
            {:
            System.out.println("SENTENCIA VACIA VALIDA");
            //LEONARDO PODES AGREGAR EL ARBOL AQUI?
                 Node x = new Node("TEST",false);
                 Node x2 = new Node("THEN",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        x.addHijo(((Node)h1).getHijos().get(i));
                }
                    
                
                x.addHijo(x2);
                RESULT = x;
            :}

     
       // Errro handler OpenTest error CloseTest
       

      |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error:erp SENTENCIA CloseTest //if sin then
        {:
        //System.out.println("open-test con error de sentencia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[1] IF sin THEN")); 
      :}

      |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error:erp CloseTest //If sin then y sentencia
        {:
        //System.out.println("open-test con error de sentencia-then");
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[2] If con sentencia-then incorrecta. No hay nada que hacer en el then.")); 
      :}

      | OpenTest Parentesis_a:erp Parentesis_c Then SENTENCIA CloseTest  // parametros if vacios
      {:
        //System.out.println("If sin condicion"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[3] If con condicion vacia.")); 
      :}
      | OpenTest Parentesis_a:erp Parentesis_c Then  CloseTest  //Parametro vacio sin sentencia.
      {:
        //System.out.println("If sin condicion y sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[4] If sin condicion y sentencia vacia.")); 
      :}
      
      | OpenTest Parentesis_a Parentesis_c error:erp  CloseTest //Parametro vacio con error en then, SENTENCIA vacia
      {:
        //System.out.println("If sin condicion y sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[5] If sin condicion y then no localizado. ")); //SENTENCIA VACIA.
      :}
      | OpenTest Parentesis_a Parentesis_c error:erp SENTENCIA CloseTest //Parametro vacio y con error en then pero con sentencia despues.
      {:
        //System.out.println("If sin condicion y sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[6] If sin condicion y then no localizado")); 
      :}
      | OpenTest:erp  Then  CloseTest //If sin condicion ni sentencia ni parentesis
      {:
        //System.out.println("If sin condicion y sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[7] If sin condicion y sentencia vacia.")); 
      :}
      | OpenTest error:erp Then SENTENCIA CloseTest //If con error en condicio.
      {:
        //System.out.println("Error en la condicion del If"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[8] If con error en condicion")); 
      :}
      | OpenTest error:erp Then error CloseTest //If con error en parametros de condicion y sentencia. 
      {:
        //System.out.println("Error en la condicion del If"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[9] If con error en condicion y sentencia")); 
      :}

      | OpenTest error:erp Then CloseTest //If con error en condicion sin sentencia.
      {:
        //System.out.println("Error en la condicion del If. if con sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[10] If con error en condicion. If con sentencia vacia")); 
      :}
      | error:erp Then CloseTest //Possible error arising here. //If sin opentest o con error en condicion.")); 
      {:
        //System.out.println("Error en la condicion del If. if con sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[11] No hay openmain, sentencia vacia" ));
      :}
      | error:erp Then SENTENCIA CloseTest //If sin opentest o con error en condicion. y CON sentencia.")); 
      {:
        //System.out.println("Error en la condicion del If"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[12] No open-main")); 
      :}
      
      
      
      
;


LISTABOOL ::= LISTABOOL:h1 SENTENCIA_BOOLEANA:h2{:
                    Node Raiz = new Node("raiz",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        Raiz.addHijo(((Node)h1).getHijos().get(i));
                     }
                     for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        Raiz.addHijo(((Node)h2).getHijos().get(i));
                     }
                     RESULT =Raiz;
                :}|
                SENTENCIA_BOOLEANA:h1{:
                    Node Raiz = new Node("raiz",false);
                    Raiz.addHijo((Node)h1);
                    RESULT = Raiz;
                :}
             
                
;
SENTENCIA_BOOLEANA ::= 
    
    //Esta parte hace falta ajustarla para lo de recursividad y lo de operaciones con precedencia y asociatividad
    SENTENCIA_BOOLEANA:h1 AND SENTENCIA_BOOLEANA:h2{:
                Node x = new Node("BOOLEAN STATEMENT",false);
                Node and = new Node("&",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        and.addHijo(((Node)h1).getHijos().get(i));
                     }
               
                
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        and.addHijo(((Node)h2).getHijos().get(i));
                     }
                x.addHijo(and);
                RESULT = x;
              :}
                
              |
              SENTENCIA_BOOLEANA:h1 OR SENTENCIA_BOOLEANA:h2
              {:
                Node x = new Node("BOOLEAN STATEMENT",false);
                Node or = new Node("|",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        or.addHijo(((Node)h1).getHijos().get(i));
                     }
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        or.addHijo(((Node)h2).getHijos().get(i));
                     }
                x.addHijo(or);
                RESULT = x;
              :}
              |
            NOT SENTENCIA_BOOLEANA:h1 {:
                Node x = new Node("BOOLEAN STATEMENT",false);
                Node not = new Node("!",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        not.addHijo(((Node)h1).getHijos().get(i));
                     }
                x.addHijo(not);
                RESULT = x;
                
              :}
              |
              
    Op_booleano:h2
          {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            Node x2 = new Node(h2.toString(),false);
            x.addHijo(x2);
            RESULT = x;
           
        :} 
    |
    Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c{:
            
            RESULT = h1;
    :}
    | 
    Identificadoroletra:h1 Op_relacional:h2 Op_booleano:h3
        {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(h3.toString(),false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
     |
    Identificadoroletra:h1 Op_relacional:h2 Numero:h3
            {: 
                Node x = new Node("BOOLEAN STATEMENT",false);
                
                Node x3 = new Node(h2.toString(),false);
                Node x4 = new Node(h3.toString(),false);
                x.addHijo((Node)h1);
                x.addHijo(x3);
                x.addHijo(x4);
                RESULT = x;
           
        :} 
            
     |
    Identificadoroletra:h1 Op_relacional:h2 Identificador:h3
               {: 
                    Node x = new Node("BOOLEANA STATEMENT",false);
                    
                    Node x3 = new Node(h2.toString(),false);
                    Node x4 = new Node(h3.toString(),false);
                    x.addHijo((Node)h1);
                    x.addHijo(x3);
                    x.addHijo(x4);
                    RESULT = x;
           
        :} 
    |
    Identificadoroletra:h1 Op_relacional:h2 Comillas Comillas
        {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(" ",false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
     |
        Identificadoroletra:h1 Op_relacional:h2 Caracter:h3
          {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(h3.toString(),false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 

     
            
;
IF_ELSE ::= OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then SENTENCIA:h2  Or SENTENCIA:h3 CloseTest 
     {: 
           Node x = new Node("TEST",false);
           Node x2 = new Node("THEN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
           }
            for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        x.addHijo(((Node)h1).getHijos().get(i));
           }
           Node x3 = new Node("OR",false);
           for(int i = 0;i<((Node)h3).getHijos().size();i++){
                x3.addHijo(((Node)h3).getHijos().get(i));
           }
           x.addHijo(x2);
           x.addHijo(x3);
            RESULT = x;
            
           
        :} 
        ////////////////////ERROR HANDLING SECTION.
        
        | OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error:erp SENTENCIA Or SENTENCIA CloseTest ////If else con error en then
        {:
        //System.out.println("open-test con error de sentencia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[1] IF ELSE con error en then.")); 
        :}
        
       

        |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error:erp Or SENTENCIA CloseTest  ///////Error en sentencia-then
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[2] IF ELSE con error en sentencia-then al inicio.")); 
        :}

        |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error:erp Or error CloseTest ///////Error en ambas sentencias del IF ELSE
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[3] IF ELSE con error en sentencia-then al inicio y en sentencia-closetest")); 
        :}

        |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then Or error:erp CloseTest  ////// Error en sentencia-closetest
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[4] IF ELSE con error en sentencia-closetest")); 
        :}
        
       
      




        | OpenTest Parentesis_a:erp Parentesis_c Then SENTENCIA Or SENTENCIA CloseTest //IF ELSE con condicion vacia
        {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[5] IF ELSE sin condicion")); 
        :}

        | OpenTest Parentesis_a  Parentesis_c error:erp SENTENCIA Or SENTENCIA CloseTest ////If else con error en then y condicion vacia
        {:
        //System.out.println("open-test con error de sentencia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[6] IF ELSE con error en [then], y condicion vacia.")); 
        :}
        |OpenTest Parentesis_a  Parentesis_c error:erp Or SENTENCIA CloseTest  ///////Error en sentencia-then
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[7] IF ELSE con error en sentencia-then al inicio, condicion vacia.")); 
        :}
        |OpenTest Parentesis_a  Parentesis_c error:erp Or error CloseTest ///////Error en ambas sentencias del IF ELSE
        {:
        //System.out.println("[8] open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[8] IF ELSE con error en sentencia-then al inicio y en sentencia-closetest. condicion vacia.")); 
        :}
        |OpenTest Parentesis_a  Parentesis_c Then Or error:erp CloseTest  ////// Error en sentencia-closetest
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[9] IF ELSE con error en sentencia-closetest , condicion vacia")); 
        :}
        

        




        /*| OpenTest Parentesis_a error Parentesis_c Then SENTENCIA Or SENTENCIA CloseTest // If else con error en la condicion
        {:
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en condicion")); 
        :}
        | OpenTest Parentesis_a error Parentesis_c Then SENTENCIA Or SENTENCIA CloseTest //IF ELSE con condicion vacia
        {:
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE error condicion")); 
        :}

        | OpenTest Parentesis_a error Parentesis_c error SENTENCIA Or SENTENCIA CloseTest ////If else con error en then y condicion vacia
        {:
        //System.out.println("open-test con error de sentencia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en [then], y condicion vacia.")); 
        :}
        |OpenTest Parentesis_a error  Parentesis_c error Or SENTENCIA CloseTest  ///////Error en sentencia-then
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then al inicio, condicion vacia.")); 
        :}
        |OpenTest Parentesis_a error Parentesis_c error Or error CloseTest ///////Error en ambas sentencias del IF ELSE
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then al inicio y en sentencia-closetest. condicion vacia.")); 
        :}
        |OpenTest Parentesis_a error Parentesis_c Then Or error CloseTest  ////// Error en sentencia-closetest
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-closetest , condicion vacia")); 
        :}*/



        | OpenTest:erp Then SENTENCIA Or SENTENCIA CloseTest   // if sin parentesis
        {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[10] IF ELSE sin condicion ni parentesis")); 
        :}


         |OpenTest error:erp Or error CloseTest /////// Error en sentencia then y sentencia-closetest
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[11] IF ELSE con error en sentencia-then y sentencia-closetest")); 
        :}

        |OpenTest error:erp SENTENCIA Or SENTENCIA CloseTest /////// Error en sentencia then.
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[12] IF ELSE con error en sentencia-then y sentencia-closetest")); 
        :}

         |OpenTest error:erp Or SENTENCIA CloseTest /////// Error en sentencia then y sentencia-closetest
        {:
        
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[13] IF ELSE con error en sentencia-then y sentencia-closetest")); 
        :}

        

        |OpenTest error:erp Then SENTENCIA Or SENTENCIA CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[14] IF ELSE con error irreconosible en la condicion.")); 
        :}

        |OpenTest error:erp Then error Or SENTENCIA CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[15] IF ELSE con error irreconosible en la condicion sentencia.")); 
        :}

        |OpenTest error:erp Or  CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[16] IF ELSE con error irreconosible en la condicion sentencia.")); 
        :}

        |OpenTest error:erp Then SENTENCIA Or error CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[17] IF ELSE con error irreconosible en la condicion sentencia-then y en Sentencia-closetest.")); 
        :}
        
        
        |OpenTest Then Or error:erp CloseTest /////// Error en sentencia-closetest.
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[18] IF ELSE con error en sentencia-then")); 
        :}

        |OpenTest error:erp SENTENCIA Or error CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[19] IF ELSE con error irreconosible en la condicion sentencia-then y en Sentencia-closetest.")); 
        :}

        |OpenTest error:erp SENTENCIA Or CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[20] IF ELSE con error irreconosible en la condicion sentencia-then. .")); 
        :}

        | error:erp Then SENTENCIA Or CloseTest //Possible error arising here. //If sin opentest o con error en condicion.")); 
      {:
        //System.out.println("Error en la condicion del If. if con sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[21] ERROR THEN CLOSETEST. No hay openmain sentencia vacia" ));
      :}
      

        /*| error Then SENTENCIA Or CloseTest //Possible error arising here. //If sin opentest o con error en condicion.")); 
      {:
        //System.out.println("Error en la condicion del If. if con sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"[22] ERROR THEN CLOSETEST. No hay openmain sentencia vacia" ));
      :}
      | error Then SENTENCIA CloseTest //If sin opentest o con error en condicion. y CON sentencia.")); 
      {:
        //System.out.println("Error en la condicion del If"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"[23] ERROR THEN SENTENCIA CLOSETEST. No open-main")); 
      :}*/

      
      
    
;
UNTIL ::= OpenUntil Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c Do SENTENCIA:h2 CloseUntil
            {:
                Node x = new Node("UNTIL",false);
                x.addHijo((Node)h1);
                Node x2 = new Node("DO",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                    x2.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(x2);
                RESULT = x;

        :}

        | OpenUntil Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c Do  CloseUntil
            {:
            System.out.println("SENTENCIA VACIA VALIDA");
            //LEONARDO PODES AGREGAR EL ARBOL AQUI?
                 Node x = new Node("TEST",false);
                 Node x2 = new Node("THEN",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        x.addHijo(((Node)h1).getHijos().get(i));
                }
                    
                
                x.addHijo(x2);
                RESULT = x;
            :}






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         //Error Handling block OpenUntil error CloseUntil

        |OpenUntil Parentesis_a SENTENCIA_BOOLEANA Parentesis_c error:erp SENTENCIA CloseUntil //OpenUntil sin Do
        {:
         parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[1]Open Until sin DO correcto.")); 
        :}

      |OpenUntil Parentesis_a SENTENCIA_BOOLEANA Parentesis_c error:erp CloseUntil //OpenUnitl sin do y sentencia
        {:
        
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[2]OpenUntil con sentencia-do incorrecta. No hay nada que hacer en el do.")); 
      :}

      | OpenUntil Parentesis_a:erp Parentesis_c Do SENTENCIA CloseUntil  // parametros Until vacios
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[3] OpenUntil con condicion vacia. .")); 
      :}
      | OpenUntil Parentesis_a:erp Parentesis_c Do  CloseUntil  //Parametro vacio sin sentencia.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[4] Until sin condicion y sentencia vacia.")); 
      :}
      
      | OpenUntil Parentesis_a Parentesis_c error:erp  CloseUntil //Parametro vacio con error en Do, SENTENCIA vacia
      {: 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[5] Until sin condicion y Do no localizado. SENTENCIA VACIA.")); 
      :}

      | OpenUntil Parentesis_a Parentesis_c error:erp  SENTENCIA CloseUntil //Parametro vacio y con error en Do pero con sentencia despues.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[6]Until sin condicion y Do no localizado")); 
      :}

      | OpenUntil:erp Do CloseUntil //Until sin condicion ni sentencia ni parentesis
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[7]Until sin condicion ni sentencia ni parentesis")); 
      :}

      | OpenUntil error:erp Do SENTENCIA CloseUntil //Until con error en condicion.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[8] Until con error en condicion")); 
      :}

      | OpenUntil error:erp Do error CloseUntil //Until con error en parametros de condicion y sentencia. 
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[9]  error en condicion y sentencia")); 
      :}

      | OpenUntil error:erp Do CloseUntil //Until con error en condicion sin sentencia.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[10] Until con error en condicion. Until con sentencia vacia"));
      :}

      | error:erp Do CloseUntil //Possible error arising here. //Until sin openUntil o con error en condicion.")); 
      {: 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[11] No hay openuntil sentencia vacia" ));
      :}

      | error:erp Do SENTENCIA CloseUntil//Do sin openuntil o con error en condicion. y CON sentencia.")); 
      {:        
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[12]  No open-until")); 
      :}
      | OpenUntil Parentesis_a Parentesis_c Do error:erp CloseUntil  // parametros Until vacios
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[13] OpenUntil con un error en su cuerpo de declaracion. .")); 
      :}
      | OpenUntil Parentesis_a SENTENCIA_BOOLEANA Parentesis_c Do error:erp CloseUntil  // parametros Until vacios
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[14] OpenUntil con un error en su cuerpo de declaracion. .")); 
      :}










;
FOR ::= OpenFor Parentesis_a SENTENCIA_FOR:h1 Parentesis_c Do SENTENCIA:h2 CloseFor 
        {:
                Node x = new Node("FOR",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                 }
           
                Node x2 = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(x2);
                RESULT = x;
        :}

        


////////////////////////////////////////////////////////////////////////////////////////
            // Error Handling Block | OpenFor error CloseFor

       |OpenFor Parentesis_a SENTENCIA_FOR Parentesis_c error:erp SENTENCIA CloseFor //OpenFor sin Do
        {:
         parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[1] OpenFor sin DO correcto.")); 
        :}

      |OpenFor Parentesis_a SENTENCIA_FOR Parentesis_c error:erp CloseFor //OpenFor sin do y sentencia
        {:
        
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[2] OpenFor con sentencia-do incorrecta. No hay nada que hacer en el do.")); 
      :}

      | OpenFor Parentesis_a:erp Parentesis_c Do SENTENCIA CloseFor  // parametros For vacios
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[3] OpenFor con condicion vacia. .")); 
      :}
      | OpenFor Parentesis_a:erp Parentesis_c Do  CloseFor  //Parametro vacio sin sentencia.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[4] OpenFor sin condicion y sentencia vacia.")); 
      :}
      
      | OpenFor Parentesis_a Parentesis_c error:erp  CloseFor //Parametro vacio con error en Do, SENTENCIA vacia
      {: 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[5] OpenFor sin condicion y Do no localizado. SENTENCIA VACIA.")); 
      :}

      | OpenFor Parentesis_a:erp Parentesis_c error  SENTENCIA CloseFor //Parametro vacio y con error en Do pero con sentencia despues.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[6] OpenFor sin condicion y Do no localizado")); 
      :}

      | OpenFor:erp Do CloseFor //Openfor sin condicion ni sentencia ni parentesis
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[7] Openfor sin condicion ni sentencia ni parentesis")); 
      :}

      | OpenFor error:erp Do SENTENCIA CloseFor //OpenFor con error en condicion.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[8] OPENFOR ERROR DO SENTENCIA CLOSEFOR. OpenFor con error en condicion")); 
      :}

      | OpenFor error:erp Do error CloseFor //OpenFor con error en parametros de condicion y sentencia. 
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[9] OPENFOR ERROR DO ERROR CLOSEFOR con error en condicion y sentencia")); 
      :}

      | OpenFor error:erp Do CloseFor //OpenFor con error en condicion sin sentencia.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[10] OPENFOR ERROR DO CLOSEFOR. OPENFOR con error en condicion. OPENFOR con sentencia vacia")); 
      :}

      | error:erp Do CloseFor //Possible error arising here. //Until sin openUntil o con error en condicion.")); 
      {: 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[11] ERROR DO CLOSEFOR. No hay OpenFor sentencia vacia" ));
      :}

      | error:erp Do SENTENCIA CloseFor//Do sin OpenFor o con error en condicion. y CON sentencia.")); 
      {:        
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[12]ERROR Do SENTENCIA CLOSEFOR OPENFOR. Do sin OpenFor o con error en condicion.")); 
      :}


;






SENTENCIA_FOR ::=
    Int Identificadoroletra:h1 Igual Numero:n P_coma SENTENCIA_BOOLEANA:h2 P_coma DECLARACION_FOR:h3
        {:
            Node raiz = new Node("ROOT",false);
            Node x = new Node("FOR STATEMENT",false);
            
            x.addHijo((Node)h1);
            x.addHijo(new Node(n.toString(),false));
            raiz.addHijo(x);
            raiz.addHijo((Node)h2);
            raiz.addHijo((Node)h3);
            RESULT = raiz;
        :}
     |
    Identificador Igual Numero P_coma SENTENCIA_BOOLEANA P_coma DECLARACION_FOR
;











LECTURA ::= Eat Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
              {:
                Node x = new Node("EAT",false);
                x.addHijo((Node)h1);
                RESULT = x;
               :}
            //Deprecation Eat L P_coma |

///////////////////////////////////////////////////////////////////////////////////////////////
            //Error handling block Eat error
             |Eat Parentesis_a:erp Parentesis_c P_coma
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[1] Eat sin Identificar o letra.")); 
             :}
             | Eat Parentesis_a Parentesis_c:erp
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[2] Eat sin Identificar o letra. y no tiene P_coma.")); 
             :}
             | Eat Parentesis_a Identificadoroletra:h1 Parentesis_c:erp
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[2] Eat sin Pcoma.")); 
             :}
             

             | Eat error:erp P_coma
             {: 
                 parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[3] Parametros del Eat no son reconocidos."));
             :}
      
             | Eat:erp P_coma
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[4] Eat sin parametro")); 
             :}
              

;








ESCRITURA ::= THrow Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROW",false);
                    x.addHijo((Node)h1);
                    RESULT = x;
               :}
             |
              Throwln Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROWLN",false);
                    x.addHijo((Node)h1);
                    RESULT = x;
               :} 
                |
               Throwln Parentesis_a SENTENCIA:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROWLN",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                            x.addHijo(((Node)h1).getHijos().get(i));
                        }
                    RESULT = x;
               :}
               |THrow Parentesis_a SENTENCIA:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROW",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                            x.addHijo(((Node)h1).getHijos().get(i));
                        }
                    RESULT = x;
               :}
               |
               Throwln Parentesis_a STRING:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROWLN",false);
                    Node x2 = new Node(h1.toString(),false);
                    x.addHijo(x2);
                    RESULT = x;
               :}
               |THrow Parentesis_a STRING:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROW",false);
                    Node x2 = new Node(h1.toString(),false);
                    x.addHijo(x2);
       
                    

                    RESULT = x;
               :}

/////////////////////////////////////////////////////////////////////////////////
              //Error handling block THrow error | Throwln error
              //Posible validacion de throw strings strings.

              | THrow Parentesis_a:erp Parentesis_c P_coma
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[1] Throw sin Identificador o letra.")); 
             :}
              | THrow Parentesis_a:erp Parentesis_c
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[2] Throw sin Identificador o letra. y no tiene P_coma.")); 
             :}
              | THrow Parentesis_a Identificadoroletra:h1 Parentesis_c:erp
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[3] Throw sin Pcoma.")); 
             :}
              | THrow error:erp P_coma
             {: 
                 parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[4] Parametros del Throw no son reconocidos."));
             :}




             | Throwln Parentesis_a:erp Parentesis_c P_coma
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[5] Throwln sin Identificar o letra.")); 
             :}
              | Throwln Parentesis_a:erp Parentesis_c
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[6] Throwln sin Identificador o letra. y no tiene P_coma.")); 
             :}
              | Throwln Parentesis_a Identificadoroletra:h1 Parentesis_c:erp
             {: 
                parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[7] Throwln sin Pcoma.")); 
             :}
              | Throwln error:erp P_coma
             {: 
                 parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[8] Parametros del Throwln no son reconocidos."));
             :}
             
;










DECLARACION_FOR ::= 
    Identificadoroletra:h1 Op_atribucion:h2 EXP:h3
    {:
        Node x = new Node("FOR DECLARATION",false);
        x.addHijo((Node)h1);
        x.addHijo(new Node(h2.toString(),false));
        x.addHijo((Node)h3);
        RESULT = x;
    :}
     |
    Identificadoroletra:h1 Op_incremento:h2
            {:
                Node x = new Node("FOR DECLARATION",false);
                x.addHijo((Node)h1);
                x.addHijo(new Node(h2.toString(),false));
                RESULT = x;
    :}
     | 
    Op_incremento:h2 Identificadoroletra:h1
         {:
                Node x = new Node("FOR DECLARATION",false);
                x.addHijo((Node)h1);
                x.addHijo(new Node(h2.toString(),false));
                RESULT = x;
    :}
;










MATCH ::= 
    OpenMatch Parentesis_a Identificadoroletra:h1 Parentesis_c Do CASE:h2 CloseMatch 
    {:
          Node x = new Node("OPENMATCH",false);
          x.addHijo((Node)h1);
          for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
           }
          RESULT = x;
    :}
    //Error Handling Block|OpenMatch Parentesis_a Identificador Parentesis_c error CloseMatch
    
      |OpenMatch Parentesis_a Identificadoroletra Parentesis_c error:erp CASE CloseMatch //OpenFor sin Do
        {:
         parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[1] OpenMatch sin DO correcto.")); 
        :}

      |OpenMatch Parentesis_a Identificadoroletra Parentesis_c error:erp CloseMatch //OpenMatch sin do y sentencia
        {:
        
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[2] OpenMatch con case-do incorrecta. No hay nada que hacer en el do.")); 
        :}

      | OpenMatch Parentesis_a:erp Parentesis_c Do CASE CloseMatch  // parametros MATCH vacios
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[3] OpenMatch con condicion vacia. .")); 
      :}
      | OpenMatch Parentesis_a:erp Parentesis_c Do CloseMatch  //Parametro vacio sin case.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[4] OpenMatch sin condicion y case vacia.")); 
      :}
      
      | OpenMatch Parentesis_a Parentesis_c error:erp  CloseMatch //Parametro vacio con error en Do, Case vacia
      {: 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[5] OpenMatch sin condicion y Do no localizado. CASE VACIA.")); 
      :}

      | OpenMatch Parentesis_a Parentesis_c error:erp CASE CloseMatch //Parametro vacio y con error en Do pero con case despues.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[6] OpenMatch sin condicion y Do no localizado")); 
      :}

      | OpenMatch:erp Do CloseMatch //OpenMatch sin condicion ni case ni parentesis
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[7] OpenMatch sin condicion ni case ni parentesis")); 
      :}

      | OpenMatch error:erp Do CASE CloseMatch //OpenMatch con error en condicion.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[8] OpenMatch con error en condicion")); 
      :}

      | OpenMatch error:erp Do error CloseMatch //OpenMatch con error en parametros de condicion y case. 
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[9] OPENMATCH ERROR DO ERROR CLOSEMATCH con error en condicion y CASE.")); 
      :}

      | OpenMatch error:erp Do CloseMatch //OpenMatch con error en condicion sin case.
      {:
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[10] OPENMatch ERROR DO CLOSEMATCH. OPENMATCH con error en condicion. OPENMATCH con CASE vacia")); 
      :}

      | error:erp Do CloseMatch //Possible error arising here. //Until sin OpenMatch o con error en condicion.")); 
      {: 
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[11] No hay OpenMatch, case vacia" ));
      :}

      | error:erp Do CASE CloseMatch//Do sin OpenMatch o con error en condicion. y CON CASE.")); 
      {:        
        parser.syntax_error(new Symbol(sym.error,erpleft,erpright,"[12]ERROR Do CASE CLOSEMATCH OPENMATCH. Do sin OpenMATCH o con error en condicion.")); 
      :}

;













CASE ::=
    //Might need some modification later
    CASE:h1 When Caracter:h2 Igual SENTENCIA:h3 Stop P_coma
            {:
                
                Node raiz = new Node("ROOT",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
                Node x = new Node("CHAR-CASE",false);
                x.addHijo(new Node((h2.toString()).substring(1,2),false));
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h3).getHijos().size();i++){
                THEN.addHijo(((Node)h3).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
    When Caracter:h1 Igual SENTENCIA:h2 Stop P_coma

       {:
                Node raiz = new Node("ROOT",false);
                Node x = new Node("CHAR-CASE",false);
                x.addHijo(new Node((h1.toString()).substring(1,2),false));
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                THEN.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
      CASE:h1 When Identificadoroletra:h2 Igual SENTENCIA:h3 Stop P_coma
            {:
                
                Node raiz = new Node("ROOT",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
                Node x = new Node("CASE",false);
                x.addHijo((Node)h2);
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h3).getHijos().size();i++){
                THEN.addHijo(((Node)h3).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
     When Identificadoroletra:h1 Igual SENTENCIA:h2 Stop P_coma

       {:
                Node raiz = new Node("Raiz",false);
                Node x = new Node("CASE",false);
                x.addHijo((Node)h1);
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                THEN.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    
;