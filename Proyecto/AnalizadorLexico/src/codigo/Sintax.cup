package codigo;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
        String error = "";
        if(s.value != null){
            error = "Error Sintactico en la linea "+s.right+ " Columna "+(s.left+1)+ ". No se esperaba esto: "+ "\""+ s.value+ "\""+ "\n" ;
           System.out.print(error);
        }
        //errores.add(error)
    }
    


    public Symbol getS(){
        return this.s;
    }
:};

terminal Linea, Comillas,Caracter, T_dato, Int,Character,OpenTest,CloseTest,Or,Then,OpenUntil,CloseUntil,Do,OpenFor,CloseFor,
    Igual, Suma, Resta, Multiplicacion, Division, Op_logico, Op_relacional,
    Op_atribucion, Op_incremento, Op_booleano, Parentesis_a, Parentesis_c,
    Llave_a, Llave_c, Corchete_a, Corchete_c, Main, P_coma, Identificador,
    Numero, ERROR,CloseMain,As,Define,L,Boolean,Eat,Throwln,THrow,OpenMatch,CloseMatch,When,Stop;
non terminal INICIO, SENTENCIA, DECLARACION, DECLARACION_FOR, IF, IF_ELSE,
    UNTIL,FOR, SENTENCIA_BOOLEANA, SENTENCIA_FOR,LECTURA,ESCRITURA,MATCH,CASE,Identificadoroletra;

start with INICIO;

INICIO ::= 

    Main Parentesis_a Parentesis_c SENTENCIA:h2 CloseMain
         {: 
           Node x = new Node("MAIN",false);
           x.addHijo((Node)h2);
           System.out.println(x.Imprimir(0)); 
          
          
        :} 
    |
    Main Parentesis_a Parentesis_c CloseMain|
    error SENTENCIA CloseMain|
    error CloseMain|
    

;

SENTENCIA ::= 
    SENTENCIA:h1 DECLARACION:h2
        {:
        Node x = new Node("SENTENCIA",false);
           x.addHijo((Node)h1);
           x.addHijo((Node)h2);
           RESULT = x; 
    :}
     |
    DECLARACION:h2
        {: Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
            :}
     |
    SENTENCIA:h1 IF:h2
           {:
           Node x = new Node("SENTENCIA",false);
           x.addHijo((Node)h1);
           x.addHijo((Node)h2);
           RESULT = x; 
    :}
     | 
    IF:h2
        {:  Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
            :}
     |
    SENTENCIA:h1 IF_ELSE:h2
            {:
                Node x = new Node("SENTENCIA",false);
                x.addHijo((Node)h1);
                x.addHijo((Node)h2);
                RESULT = x; 
            :}
        
     |
    IF_ELSE:h2 
    {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :} |
    SENTENCIA:h1 UNTIL:h2
    {:
                Node x = new Node("SENTENCIA",false);
                x.addHijo((Node)h1);
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    UNTIL:h2
         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
     |
    SENTENCIA:h1 FOR:h2
     {:
                Node x = new Node("SENTENCIA",false);
                x.addHijo((Node)h1);
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
     |
    FOR:h2
            {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    
     |
    SENTENCIA:h1 LECTURA:h2
       {:
                Node x = new Node("SENTENCIA",false);
                x.addHijo((Node)h1);
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    LECTURA:h2
            {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    |
    SENTENCIA:h1 ESCRITURA:h2
               {:
                Node x = new Node("SENTENCIA",false);
                x.addHijo((Node)h1);
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    ESCRITURA:h2
           {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
        
    |
    SENTENCIA:h1 MATCH:h2
              {:
                Node x = new Node("SENTENCIA",false);
                x.addHijo((Node)h1);
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
        
    |
    MATCH:h2

         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    
    
    
;
Identificadoroletra ::= 
    Identificador:h1
         {:  Node x = new Node(h1.toString(),false);
            
            RESULT = x;
            :}
    |
    L:h1
    {:  Node x = new Node(h1.toString(),false);
            
            RESULT = x;
            :}
;
DECLARACION ::= 
    //Int
    Define Identificadoroletra:h2 As Int P_coma
         {: 
        Node x = new Node("DECLARACION",false);
        Node x2 = new Node("integer",false);
        
        x.addHijo(x2);
        x.addHijo((Node)h2);
        RESULT = x;
        :} 
    |
    Define Identificadoroletra:h2 As Int Igual Numero:n P_coma
        {: 
        Node x = new Node("DECLARACION",false);
        Node x2 = new Node("integer",false);
        Node x4 = new Node(n.toString(),false);
        x.addHijo(x2);
        x.addHijo((Node)h2);
        x.addHijo(x4);
        RESULT = x;
        :} 
    |

    // int array
    Define Identificadoroletra:h1 As Int Corchete_a Numero:n Corchete_c P_coma
        {:
              
                Node x = new Node("DECLARACION",false);
                Node x2 = new Node("integer array",false);
                Node x4 = new Node("["+n.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |
    // int matriz
    Define Identificadoroletra:h1 As Int Corchete_a Numero:n1 Corchete_c Corchete_a Numero:n2 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARACION",false);
                Node x2 = new Node("integer matrix",false);
                Node x4 = new Node("["+n1.toString()+"]"+"["+n2.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |

   
    //Deprecated
    //Define L As Int P_coma|  
    //Define L As Int Igual Numero P_coma|
    


    //Char
    Define Identificadoroletra:h1 As Character P_coma
        {: 
            Node x = new Node("DECLARACION",false);
            Node x2 = new Node("character",false);
            x.addHijo(x2);
            x.addHijo((Node)h1);
            RESULT = x;
        :} 
    |
    Define Identificadoroletra:h1 As Character Igual Caracter:c1 P_coma
          {: 
            Node x = new Node("DECLARACION",false);
            Node x2 = new Node("character",false);
            Node x3 = new Node(c1.toString(),false);
            x.addHijo(x2);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            RESULT = x;
        :} 
    |
    
     // char array
    Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARACION",false);
                Node x2 = new Node("character array",false);
                Node x4 = new Node("["+c1.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |
    // char matriz
    Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c Corchete_a Numero:c2 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARACION",false);
                Node x2 = new Node("character matrix",false);
                Node x4 = new Node("["+c1.toString()+"]"+"["+c2.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    
    |


    //Deprecated
    //Define L As Character P_coma|
    //Define L As Character Igual Comillas Identificador Comillas P_coma|

    //boolean
    Define Identificadoroletra:h1 As Boolean P_coma
            {: 
                Node x = new Node("DECLARACION",false);
                Node x2 = new Node("boolean",false);
               
                x.addHijo(x2);
                x.addHijo((Node)h1);
                RESULT = x;
        :} 
    |
    Define Identificadoroletra:h1 As Boolean Igual Op_booleano:b1 P_coma
          {: 
                Node x = new Node("DECLARACION",false);
                Node x2 = new Node("boolean",false);
                
                Node x4 = new Node(b1.toString(),false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        :} 
    |
    
    //Deprecated
    //Define L As Boolean P_coma|
    //Define L As Boolean Igual Op_booleano P_coma|

    /* ERROR HANDLING BLOCK FOR DECLARATIONS*/
    error P_coma

    


    /*Int Identificador P_coma | 
    Int Identificador Op_atribucion Numero P_coma |
    Int Identificador Igual Numero P_coma |
    Int Identificador Op_incremento P_coma | 
    Int Op_incremento Identificador P_coma | 
    T_dato Identificador P_coma | 
    T_dato Identificador Op_atribucion Numero P_coma |
    T_dato Identificador Igual Numero P_coma |
    T_dato Identificador Op_incremento P_coma | 
    T_dato Op_incremento Identificador P_coma | 
    Cadena Identificador Op_atribucion Comillas Comillas P_coma |
    Cadena Identificador Igual Comillas Comillas P_coma |
    Cadena Identificador Op_atribucion Comillas Identificador Comillas P_coma |
    Cadena Identificador Igual Comillas Identificador Comillas P_coma*/
;
IF ::= OpenTest Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c Then SENTENCIA:h2 CloseTest
         {: 
           Node x = new Node("OPEN-TEST",false);
           Node x2 = new Node("THEN",false);
           x.addHijo((Node)h1);
           x2.addHijo((Node)h2);
            
            x.addHijo(x2);
            RESULT = x;
            
           
        :} 
       // Errro handler OpenTest error CloseTest
;
SENTENCIA_BOOLEANA ::= 
    //Esta parte hace falta ajustarla para lo de recursividad y lo de operaciones con precedencia y asociatividad
    Op_booleano:h2
          {: 
            Node x = new Node("SENTENCIA_BOOLEANA",false);
            Node x2 = new Node(h2.toString(),false);
            x.addHijo(x2);
            RESULT = x;
           
        :} 
    | 
    Identificadoroletra:h1 Op_relacional:h2 Op_booleano:h3
        {: 
            Node x = new Node("SENTENCIA_BOOLEANA",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(h3.toString(),false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
     |
    Identificadoroletra:h1 Op_relacional:h2 Numero:h3
            {: 
                Node x = new Node("SENTENCIA_BOOLEANA",false);
                
                Node x3 = new Node(h2.toString(),false);
                Node x4 = new Node(h3.toString(),false);
                x.addHijo((Node)h1);
                x.addHijo(x3);
                x.addHijo(x4);
                RESULT = x;
           
        :} 
            
     |
    Identificadoroletra:h1 Op_relacional:h2 Identificador:h3
               {: 
                    Node x = new Node("SENTENCIA_BOOLEANA",false);
                    
                    Node x3 = new Node(h2.toString(),false);
                    Node x4 = new Node(h3.toString(),false);
                    x.addHijo((Node)h1);
                    x.addHijo(x3);
                    x.addHijo(x4);
                    RESULT = x;
           
        :} 
    |
    Identificadoroletra:h1 Op_relacional:h2 Comillas Comillas
        {: 
            Node x = new Node("SENTENCIA_BOOLEANA",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(" ",false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
     |
        Identificadoroletra:h1 Op_relacional:h2 Caracter:h3
          {: 
            Node x = new Node("SENTENCIA_BOOLEANA",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(h3.toString(),false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
            
;
IF_ELSE ::= OpenTest Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c Then SENTENCIA:h2  Or SENTENCIA:h3 CloseTest 
     {: 
           Node x = new Node("OPEN-TEST",false);
           Node x2 = new Node("THEN",false);
           x.addHijo((Node)h1);
           x2.addHijo((Node)h2);
           Node x3 = new Node("OR",false);
           x3.addHijo((Node)h3);
           x.addHijo(x2);
           x.addHijo(x3);
            RESULT = x;
            
           
        :} 
    
    /*
            OpenTest error Then SENTENCIA error SENTENCIA CloseTest|
            OpenTest error Then SENTENCIA Or SENTENCIA CloseTest |
            OpenTest Parentesis_a SENTENCIA_BOOLEANA Parentesis_c Then SENTENCIA error SENTENCIA CloseTest
    */
;
UNTIL ::= OpenUntil Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c Do SENTENCIA:h2 CloseUntil
            {:
                Node x = new Node("OPEN-UNTIL",false);
                x.addHijo((Node)h1);
                Node x2 = new Node("DO",false);
                x2.addHijo((Node)h2);
                x.addHijo(x2);
                RESULT = x;

        :}
         //Error Handling block OpenUntil error CloseUntil
;
FOR ::= OpenFor Parentesis_a SENTENCIA_FOR:h1 Parentesis_c  SENTENCIA:h2 CloseFor 
        {:
                Node x = new Node("OPEN-FOR",false);
                x.addHijo((Node)h1);
                Node x2 = new Node("DO",false);
                x2.addHijo((Node)h2);
                x.addHijo(x2);
                RESULT = x;
        :}

            // Error Handling Block | OpenFor error CloseFor
;
SENTENCIA_FOR ::=
    Int Identificadoroletra:h1 Igual Numero:n P_coma SENTENCIA_BOOLEANA:h2 P_coma DECLARACION_FOR:h3
        {:
            Node x = new Node("SENTENCIA FOR",false);
            x.addHijo((Node)h1);
            x.addHijo(new Node(n.toString(),false));
            x.addHijo((Node)h2);
            x.addHijo((Node)h3);
            RESULT = x;
        :}
     |
    Identificador Igual Numero P_coma SENTENCIA_BOOLEANA P_coma DECLARACION_FOR
;

LECTURA ::= Eat Identificadoroletra:h1 P_coma
              {:
                Node x = new Node("EAT",false);
                x.addHijo((Node)h1);
                RESULT = x;
               :}
            //Deprecation Eat L P_coma |
            //Error handling block Eat error
;
ESCRITURA ::= THrow Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROW",false);
                    x.addHijo((Node)h1);
                    RESULT = x;
               :}
             |
              Throwln Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROWLN",false);
                    x.addHijo((Node)h1);
                    RESULT = x;
               :}
              //Error handling block THrow error | Throwln error
              //Posible validacion de throw strings strings.
;
DECLARACION_FOR ::= 
    Identificadoroletra:h1 Op_atribucion:h2 Numero:h3
    {:
        Node x = new Node("DECLARACION FOR",false);
        x.addHijo((Node)h1);
        x.addHijo(new Node(h2.toString(),false));
        x.addHijo(new Node(h3.toString(),false));
        RESULT = x;
    :}
     |
    Identificadoroletra:h1 Op_incremento:h2
            {:
                Node x = new Node("DECLARACION FOR",false);
                x.addHijo((Node)h1);
                x.addHijo(new Node(h2.toString(),false));
                RESULT = x;
    :}
     | 
    Op_incremento:h2 Identificadoroletra:h1
         {:
                Node x = new Node("DECLARACION FOR",false);
                x.addHijo((Node)h1);
                x.addHijo(new Node(h2.toString(),false));
                RESULT = x;
    :}
;

MATCH ::= 
    OpenMatch Parentesis_a Identificadoroletra Parentesis_c CASE CloseMatch 
    {:
          Node x = new Node("OPENMATCH",false);
          RESULT = x;
    :}
    //Error Handling Block|OpenMatch Parentesis_a Identificador Parentesis_c error CloseMatch
;

CASE ::=
    //Might need some modification later
    CASE When Comillas Identificadoroletra Comillas Igual SENTENCIA Stop P_coma
            {:
                Node x = new Node("CASE",false);
                RESULT = x;
    :}
    |
    When Comillas Identificadoroletra Comillas Igual SENTENCIA Stop P_coma

       {:
                Node x = new Node("CASE",false);
                RESULT = x;
    :}
;