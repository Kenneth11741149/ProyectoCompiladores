package codigo;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
        String error = "";
        if(s.value != null){
            error = "Error Sintactico en la linea "+s.right+ " Columna "+(s.left+1)+ ". No se esperaba esto: "+ "\""+ s.value+ "\""+ "\n" ;
           System.out.print(error);
        }
        //errores.add(error)
    }
    


    public Symbol getS(){
        return this.s;
    }
:};

terminal Linea, Comillas,Caracter, T_dato, Int,Character,OpenTest,CloseTest,Or,Then,OpenUntil,CloseUntil,Do,OpenFor,CloseFor,
    Igual, Suma, Resta, Multiplicacion, Division, Op_logico, Op_relacional,Return,
    Op_atribucion, Op_incremento, Op_booleano, Parentesis_a, Parentesis_c,OpenMethod,CloseMethod,
    Llave_a, Llave_c, Corchete_a, Corchete_c, Main, P_coma, Identificador,Coma,
    Numero, ERROR,CloseMain,As,Define,L,Boolean,Eat,Throwln,THrow,OpenMatch,CloseMatch,When,Stop,AND,OR,NOT;
non terminal INICIO, SENTENCIA, DECLARACION, DECLARACION_FOR, IF, IF_ELSE,
    UNTIL,FOR, SENTENCIA_BOOLEANA, SENTENCIA_FOR,LECTURA,ESCRITURA,MATCH,CASE,Identificadoroletra,METHOD,CALLMETHOD,LISTABOOL,EXP,E,T,F,PARAMETROS,PARAMETROS2;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left NOT;


start with INICIO;

INICIO ::= 

    Main Parentesis_a Parentesis_c SENTENCIA:h2 CloseMain
         {: 
           Node raiz = new Node("ROOT",false);
           Node x = new Node("MAIN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
            }
           //x.addHijo((Node)h2);
           raiz.addHijo(x);
           System.out.println(raiz.Imprimir(0)); 
          
          
          
        :} 
    |
    Main Parentesis_a Parentesis_c CloseMain|
    Main Parentesis_a Parentesis_c SENTENCIA:h2 CloseMain METHOD:h3
    {: 
           Node raiz = new Node("ROOT",false);
           
           Node x = new Node("MAIN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
            }
           //x.addHijo((Node)h2);
           raiz.addHijo(x);
           for(int i = 0;i<((Node)h3).getHijos().size();i++){
                raiz.addHijo(((Node)h3).getHijos().get(i));
            }
           
           System.out.println(raiz.Imprimir(0));
           
          
          
        :} 
    |error SENTENCIA CloseMain
      {: System.out.println("Error SENTENCIA CloseMain");  :} //Todo error desde el inicio hasta alguna sentencia.
                                                              //Error en la declaracion del main.
    |error CloseMain
      {: System.out.println("Error CloseMain");  :} //Todo error que venga desde el inicio hasta el CloseMain es cubierto.
                                                    //Error en la declaracion de un main vacio.
    |error
      {: System.out.println("ERROR No se reconoce la intencion ingresada.");  :} //Todo error que no se recupere
                                                                          //Unrecognized code.

    | Main error
      {: System.out.println("Main Error");  :} //Todo error que no se recupere
                                                                          //Unrecognized code.
    | {: System.out.println("No hay un codigo para analizar.");  :} //No hay codigo para
    

;





SENTENCIA ::= 
    SENTENCIA:h1 DECLARACION:h2
        {:
           
           Node x = new Node("SENTENCIA",false);
           for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
           x.addHijo((Node)h2);
           RESULT = x; 
    :}
     |
    DECLARACION:h2
        {: Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
            :}
     |
    SENTENCIA:h1 IF:h2
           {:
           Node x = new Node("SENTENCIA",false);
            for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
           x.addHijo((Node)h2);
           RESULT = x; 
    :}
     | 
    IF:h2
        {:  Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
            :}
     |
    SENTENCIA:h1 IF_ELSE:h2
            {:
                Node x = new Node("SENTENCIA",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                x.addHijo((Node)h2);
                RESULT = x; 
            :}
        
     |
    IF_ELSE:h2 
    {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :} |
    SENTENCIA:h1 UNTIL:h2
    {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
               
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    UNTIL:h2
         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
     |
    SENTENCIA:h1 FOR:h2
     {:
                Node x = new Node("SENTENCIA",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
               
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
     |
    FOR:h2
            {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    
     |
    SENTENCIA:h1 LECTURA:h2
       {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    LECTURA:h2
            {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    |
    SENTENCIA:h1 ESCRITURA:h2
               {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    ESCRITURA:h2
           {:
            Node x = new Node("SENTENCIA",false);
            
            x.addHijo((Node)h2);
            RESULT = x;
    :}
        
    |
    SENTENCIA:h1 MATCH:h2
              {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}     
    |
    MATCH:h2

         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    | SENTENCIA:h1 CALLMETHOD:h2
    {:
        Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    CALLMETHOD:h2

         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    
    
;

PARAMETROS2::= Identificadoroletra:h1{:
           Node raiz = new Node("PARAMETROS",false);
           raiz.addHijo((Node)h1);
           RESULT = raiz;
           :}

        |  Numero:h1{:
           Node raiz = new Node("PARAMETROS",false);
           Node x = new Node(h1.toString(),false);
           raiz.addHijo(x);
           RESULT = raiz;
           :}

        |
        PARAMETROS2:h1 P_coma Identificadoroletra:h2
        {:
        Node raiz = new Node("PARAMETROS",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
        
           raiz.addHijo((Node)h2);
           RESULT = raiz;
:}
    |
        PARAMETROS2:h1 P_coma Numero:h2
        {:
        Node raiz = new Node("PARAMETROS",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
           Node x = new Node(h2.toString(),false);
           raiz.addHijo(x);
           RESULT = raiz;
:}

|{:
    Node raiz = new Node("PARAMETROS",false);
    RESULT = raiz;
:}
;

PARAMETROS::=  Int Identificadoroletra:h1{:
           Node raiz = new Node("RAIZ",false);
           raiz.addHijo(new Node("INTEGER",false));
           raiz.addHijo((Node)h1);
           RESULT = raiz;
           :}
        |
        PARAMETROS:h1 P_coma Int Identificadoroletra:h2
        {:
        Node raiz = new Node("RAIZ",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
        raiz.addHijo(new Node("INTEGER",false));
           raiz.addHijo((Node)h2);
           RESULT = raiz;
:}
;
EXP ::= E:e 
{: RESULT = e;  :}
;

E ::=   E:e Suma T:t {: 
        Node x = new Node("+",false);
        x.addHijo((Node)e);
        x.addHijo((Node)t);
        RESULT = x;  :}
        |
        E:e Resta T:t {: 
        Node x = new Node("-",false);
        x.addHijo((Node)e);
        x.addHijo((Node)t);
        RESULT = x;  :}
        |
        T:t{:
            RESULT = t;
        :}
        

;

T ::=  T:t Multiplicacion F:f{:
        Node x = new Node("*",false);
        x.addHijo((Node)t);
        x.addHijo((Node)f);
        RESULT = x;
        :} 
        |
        T:t Division F:f{:
        Node x = new Node("/",false);
        x.addHijo((Node)t);
        x.addHijo((Node)f);
        RESULT = x;
        :}
        |
        F:f {:
        RESULT = f;
        :}
;

F ::=   Numero:h1{:
            Node x = new Node(h1.toString(),false);
            RESULT = x;
            :}
        |
        Identificadoroletra:h1{:
        RESULT = h1;
        :}
        |Parentesis_a E:e Parentesis_c{:
            RESULT = e;
        :}
        
;


METHOD ::=
    OpenMethod Int Identificadoroletra:h1 Parentesis_a Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        Node x = new Node("INTEGER METHOD",false);
        x.addHijo((Node)h1);
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT =  raiz; 
    :}

    |
    OpenMethod Int Identificadoroletra:h1 Parentesis_a PARAMETROS:params Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        Node x = new Node("INTEGER METHOD",false);
        x.addHijo((Node)h1);
        for(int i = 0;i<((Node)params).getHijos().size();i++){
                x.addHijo(((Node)params).getHijos().get(i));
            }
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT =  raiz; 
    :}
    
    |
     METHOD:m1 OpenMethod Int Identificadoroletra:h1 Parentesis_a  Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        for(int i = 0;i<((Node)m1).getHijos().size();i++){
                raiz.addHijo(((Node)m1).getHijos().get(i));
            }
        Node x = new Node("INTEGER METHOD",false);
        x.addHijo((Node)h1);
        
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT = raiz; 
    :}
    |
    METHOD:m1 OpenMethod Int Identificadoroletra:h1 Parentesis_a PARAMETROS:params Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        for(int i = 0;i<((Node)m1).getHijos().size();i++){
                raiz.addHijo(((Node)m1).getHijos().get(i));
            }
        Node x = new Node("INTEGER METHOD",false);
        x.addHijo((Node)h1);
        for(int i = 0;i<((Node)params).getHijos().size();i++){
                x.addHijo(((Node)params).getHijos().get(i));
            }
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT = raiz; 
    :}
    
;
Identificadoroletra ::= 
    Identificador:h1
         {:  Node x = new Node(h1.toString(),false);
            
            RESULT = x;
            :}
    |
    L:h1
    {:  Node x = new Node(h1.toString(),false);
            
            RESULT = x;
            :}
;

CALLMETHOD ::=
    Identificadoroletra:h1 Parentesis_a PARAMETROS2:h2 Parentesis_c P_coma
    {:
    Node x = new Node("METHOD-CALL",true);
    x.addHijo((Node)h1);
    x.addHijo((Node)h2);
    RESULT = x;
    :}
;
DECLARACION ::= 
    //Int
    Define Identificadoroletra:h2 As Int P_coma
         {: 
        Node x = new Node("DECLARATION",false);
        Node x2 = new Node("integer",false);
        
        x.addHijo(x2);
        x.addHijo((Node)h2);
        RESULT = x;
        :} 
    |
     
     Define Identificadoroletra:h2 As Int Igual EXP:h1 P_coma
        {: 
        Node x = new Node("DECLARATION",false);
        Node x2 = new Node("integer",false);
       
        x.addHijo(x2);
        x.addHijo((Node)h2);
        x.addHijo((Node)h1);
        RESULT = x;
        :} 
    |
    Identificadoroletra:h1 Igual EXP:h2 P_coma
        {:
        Node x = new Node("ASSIGNMENT",false);
        x.addHijo((Node)h1);
        x.addHijo((Node)h2);
        RESULT = x;
        :}
    
    |
    Identificadoroletra:h1 Igual CALLMETHOD:h2
        {:
        Node x = new Node("ASSIGNMENT",false);
        x.addHijo((Node)h1);
        x.addHijo((Node)h2);
        RESULT = x;
        :}
    
    |
    
    // int array
    Define Identificadoroletra:h1 As Int Corchete_a Numero:n Corchete_c P_coma
        {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("integer array",false);
                Node x4 = new Node("["+n.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |
    // int matriz
    Define Identificadoroletra:h1 As Int Corchete_a Numero:n1 Corchete_c Corchete_a Numero:n2 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("integer matrix",false);
                Node x4 = new Node("["+n1.toString()+"]"+"["+n2.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |

   
    //Deprecated
    //Define L As Int P_coma|  
    //Define L As Int Igual Numero P_coma|
    


    //Char
    Define Identificadoroletra:h1 As Character P_coma
        {: 
            Node x = new Node("DECLARATION",false);
            Node x2 = new Node("character",false);
            x.addHijo(x2);
            x.addHijo((Node)h1);
            RESULT = x;
        :} 
    |
    Define Identificadoroletra:h1 As Character Igual Caracter:c1 P_coma
          {: 
            Node x = new Node("DECLARATION",false);
            Node x2 = new Node("character",false);
            Node x3 = new Node(c1.toString(),false);
            x.addHijo(x2);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            RESULT = x;
        :} 
    |
    
     // char array
    Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("character array",false);
                Node x4 = new Node("["+c1.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |
    // char matriz
    Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c Corchete_a Numero:c2 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("character matrix",false);
                Node x4 = new Node("["+c1.toString()+"]"+"["+c2.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    
    |


    //Deprecated
    //Define L As Character P_coma|
    //Define L As Character Igual Comillas Identificador Comillas P_coma|

    //boolean
    Define Identificadoroletra:h1 As Boolean P_coma
            {: 
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("boolean",false);
               
                x.addHijo(x2);
                x.addHijo((Node)h1);
                RESULT = x;
        :} 
    |
    Define Identificadoroletra:h1 As Boolean Igual Op_booleano:b1 P_coma
          {: 
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("boolean",false);
                
                Node x4 = new Node(b1.toString(),false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        :} 
    
    
    //Deprecated
    //Define L As Boolean P_coma|
    //Define L As Boolean Igual Op_booleano P_coma|

    /* ERROR HANDLING BLOCK FOR DECLARATIONS*/
    | error P_coma
    {: System.out.println("error P_Coma en Declaracion de sentencia"); :} //hubo un error en la declaracion de variable.
    | error DECLARACION
    {: System.out.println("error SENTENCIA en Declaracion"); :} //hubo un error en la declaracion de variable.
    

    


    /*Int Identificador P_coma | 
    Int Identificador Op_atribucion Numero P_coma |
    Int Identificador Igual Numero P_coma |
    Int Identificador Op_incremento P_coma | 
    Int Op_incremento Identificador P_coma | 
    T_dato Identificador P_coma | 
    T_dato Identificador Op_atribucion Numero P_coma |
    T_dato Identificador Igual Numero P_coma |
    T_dato Identificador Op_incremento P_coma | 
    T_dato Op_incremento Identificador P_coma | 
    Cadena Identificador Op_atribucion Comillas Comillas P_coma |
    Cadena Identificador Igual Comillas Comillas P_coma |
    Cadena Identificador Op_atribucion Comillas Identificador Comillas P_coma |
    Cadena Identificador Igual Comillas Identificador Comillas P_coma*/
;
IF ::= OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then SENTENCIA:h2 CloseTest
         {: 
           Node x = new Node("TEST",false);
           Node x2 = new Node("THEN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
           }
           for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        x.addHijo(((Node)h1).getHijos().get(i));
           }
           
           x.addHijo(x2);
           RESULT = x;
            
           
        :} 
       // Errro handler OpenTest error CloseTest
;


LISTABOOL ::= LISTABOOL:h1 SENTENCIA_BOOLEANA:h2{:
                    Node Raiz = new Node("raiz",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        Raiz.addHijo(((Node)h1).getHijos().get(i));
                     }
                     for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        Raiz.addHijo(((Node)h2).getHijos().get(i));
                     }
                     RESULT =Raiz;
                :}|
                SENTENCIA_BOOLEANA:h1{:
                    Node Raiz = new Node("raiz",false);
                    Raiz.addHijo((Node)h1);
                    RESULT = Raiz;
                :}
             
                
;
SENTENCIA_BOOLEANA ::= 
    
    //Esta parte hace falta ajustarla para lo de recursividad y lo de operaciones con precedencia y asociatividad
    SENTENCIA_BOOLEANA:h1 AND SENTENCIA_BOOLEANA:h2{:
                Node x = new Node("BOOLEAN SATEMENT",false);
                Node and = new Node("&",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        and.addHijo(((Node)h1).getHijos().get(i));
                     }
               
                
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        and.addHijo(((Node)h2).getHijos().get(i));
                     }
                x.addHijo(and);
                RESULT = x;
              :}
                
              |
              SENTENCIA_BOOLEANA:h1 OR SENTENCIA_BOOLEANA:h2
              {:
                Node x = new Node("BOOLEAN SATEMENT",false);
                Node or = new Node("|",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        or.addHijo(((Node)h1).getHijos().get(i));
                     }
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        or.addHijo(((Node)h2).getHijos().get(i));
                     }
                x.addHijo(or);
                RESULT = x;
              :}
              |
            NOT SENTENCIA_BOOLEANA:h1 {:
                Node x = new Node("BOOLEAN SATEMENT",false);
                Node not = new Node("!",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        not.addHijo(((Node)h1).getHijos().get(i));
                     }
                x.addHijo(not);
                RESULT = x;
                
              :}
              |
              
    Op_booleano:h2
          {: 
            Node x = new Node("BOOLEAN SATEMENT",false);
            Node x2 = new Node(h2.toString(),false);
            x.addHijo(x2);
            RESULT = x;
           
        :} 
    |
    Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c{:
            
            RESULT = h1;
    :}
    | 
    Identificadoroletra:h1 Op_relacional:h2 Op_booleano:h3
        {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(h3.toString(),false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
     |
    Identificadoroletra:h1 Op_relacional:h2 Numero:h3
            {: 
                Node x = new Node("BOOLEAN STATEMENT",false);
                
                Node x3 = new Node(h2.toString(),false);
                Node x4 = new Node(h3.toString(),false);
                x.addHijo((Node)h1);
                x.addHijo(x3);
                x.addHijo(x4);
                RESULT = x;
           
        :} 
            
     |
    Identificadoroletra:h1 Op_relacional:h2 Identificador:h3
               {: 
                    Node x = new Node("BOOLEANA STATEMENT",false);
                    
                    Node x3 = new Node(h2.toString(),false);
                    Node x4 = new Node(h3.toString(),false);
                    x.addHijo((Node)h1);
                    x.addHijo(x3);
                    x.addHijo(x4);
                    RESULT = x;
           
        :} 
    |
    Identificadoroletra:h1 Op_relacional:h2 Comillas Comillas
        {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(" ",false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
     |
        Identificadoroletra:h1 Op_relacional:h2 Caracter:h3
          {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(h3.toString(),false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
            
;
IF_ELSE ::= OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then SENTENCIA:h2  Or SENTENCIA:h3 CloseTest 
     {: 
           Node x = new Node("TEST",false);
           Node x2 = new Node("THEN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
           }
            for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        x.addHijo(((Node)h1).getHijos().get(i));
           }
           Node x3 = new Node("OR",false);
           for(int i = 0;i<((Node)h3).getHijos().size();i++){
                x3.addHijo(((Node)h3).getHijos().get(i));
           }
           x.addHijo(x2);
           x.addHijo(x3);
            RESULT = x;
            
           
        :} 
    
    /*
            OpenTest error Then SENTENCIA error SENTENCIA CloseTest|
            OpenTest error Then SENTENCIA Or SENTENCIA CloseTest |
            OpenTest Parentesis_a SENTENCIA_BOOLEANA Parentesis_c Then SENTENCIA error SENTENCIA CloseTest
    */
;
UNTIL ::= OpenUntil Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c Do SENTENCIA:h2 CloseUntil
            {:
                Node x = new Node("UNTIL",false);
                x.addHijo((Node)h1);
                Node x2 = new Node("DO",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                    x2.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(x2);
                RESULT = x;

        :}
         //Error Handling block OpenUntil error CloseUntil
;
FOR ::= OpenFor Parentesis_a SENTENCIA_FOR:h1 Parentesis_c  SENTENCIA:h2 CloseFor 
        {:
                Node x = new Node("FOR",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                 }
           
                Node x2 = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(x2);
                RESULT = x;
        :}

            // Error Handling Block | OpenFor error CloseFor
;
SENTENCIA_FOR ::=
    Int Identificadoroletra:h1 Igual Numero:n P_coma SENTENCIA_BOOLEANA:h2 P_coma DECLARACION_FOR:h3
        {:
            Node raiz = new Node("ROOT",false);
            Node x = new Node("FOR STATEMENT",false);
            
            x.addHijo((Node)h1);
            x.addHijo(new Node(n.toString(),false));
            raiz.addHijo(x);
            raiz.addHijo((Node)h2);
            raiz.addHijo((Node)h3);
            RESULT = raiz;
        :}
     |
    Identificador Igual Numero P_coma SENTENCIA_BOOLEANA P_coma DECLARACION_FOR
;

LECTURA ::= Eat Identificadoroletra:h1 P_coma
              {:
                Node x = new Node("EAT",false);
                x.addHijo((Node)h1);
                RESULT = x;
               :}
            //Deprecation Eat L P_coma |
            //Error handling block Eat error
;
ESCRITURA ::= THrow Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROW",false);
                    x.addHijo((Node)h1);
                    RESULT = x;
               :}
             |
              Throwln Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROWLN",false);
                    x.addHijo((Node)h1);
                    RESULT = x;
               :} 
                |
               Throwln Parentesis_a SENTENCIA:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROWLN",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                            x.addHijo(((Node)h1).getHijos().get(i));
                        }
                    RESULT = x;
               :}
               |THrow Parentesis_a SENTENCIA:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROW",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                            x.addHijo(((Node)h1).getHijos().get(i));
                        }
                    RESULT = x;
               :}
              //Error handling block THrow error | Throwln error
              //Posible validacion de throw strings strings.
;
DECLARACION_FOR ::= 
    Identificadoroletra:h1 Op_atribucion:h2 EXP:h3
    {:
        Node x = new Node("FOR DECLARATION",false);
        x.addHijo((Node)h1);
        x.addHijo(new Node(h2.toString(),false));
        x.addHijo((Node)h3);
        RESULT = x;
    :}
     |
    Identificadoroletra:h1 Op_incremento:h2
            {:
                Node x = new Node("FOR DECLARATION",false);
                x.addHijo((Node)h1);
                x.addHijo(new Node(h2.toString(),false));
                RESULT = x;
    :}
     | 
    Op_incremento:h2 Identificadoroletra:h1
         {:
                Node x = new Node("FOR DECLARATION",false);
                x.addHijo((Node)h1);
                x.addHijo(new Node(h2.toString(),false));
                RESULT = x;
    :}
;

MATCH ::= 
    OpenMatch Parentesis_a Identificadoroletra:h1 Parentesis_c CASE:h2 CloseMatch 
    {:
          Node x = new Node("OPENMATCH",false);
          x.addHijo((Node)h1);
          for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
           }
          RESULT = x;
    :}
    //Error Handling Block|OpenMatch Parentesis_a Identificador Parentesis_c error CloseMatch
    
;

CASE ::=
    //Might need some modification later
    CASE:h1 When Caracter:h2 Igual SENTENCIA:h3 Stop P_coma
            {:
                
                Node raiz = new Node("ROOT",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
                Node x = new Node("CHAR-CASE",false);
                x.addHijo(new Node((h2.toString()).substring(1,2),false));
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h3).getHijos().size();i++){
                THEN.addHijo(((Node)h3).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
    When Caracter:h1 Igual SENTENCIA:h2 Stop P_coma

       {:
                Node raiz = new Node("ROOT",false);
                Node x = new Node("CHAR-CASE",false);
                x.addHijo(new Node((h1.toString()).substring(1,2),false));
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                THEN.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
      CASE:h1 When Identificadoroletra:h2 Igual SENTENCIA:h3 Stop P_coma
            {:
                
                Node raiz = new Node("ROOT",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
                Node x = new Node("CASE",false);
                x.addHijo((Node)h2);
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h3).getHijos().size();i++){
                THEN.addHijo(((Node)h3).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
     When Identificadoroletra:h1 Igual SENTENCIA:h2 Stop P_coma

       {:
                Node raiz = new Node("Raiz",false);
                Node x = new Node("CASE",false);
                x.addHijo((Node)h1);
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                THEN.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
;