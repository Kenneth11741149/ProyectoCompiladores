package codigo;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
        String error = "";
        if(s.value != null){
            error = "Error Sintactico en la linea "+s.right+ " Columna "+(s.left+1)+ ". No se esperaba esto: "+ "\""+ s.value+ "\""+ "\n" ;
           System.out.print(error);
        }
        //errores.add(error)
    }
    
    protected int error_sync_size(){
        return 2;
    }
    


    public Symbol getS(){
        return this.s;
    }
:};

terminal Linea, Comillas,Caracter, T_dato, Int,Character,OpenTest,CloseTest,Or,Then,OpenUntil,CloseUntil,Do,OpenFor,CloseFor,
    Igual, Suma, Resta, Multiplicacion, Division, Op_logico, Op_relacional,Return,
    Op_atribucion, Op_incremento, Op_booleano, Parentesis_a, Parentesis_c,OpenMethod,CloseMethod,
    Llave_a, Llave_c, Corchete_a, Corchete_c, Main, P_coma, Identificador,Coma,
    Numero, ERROR,CloseMain,As,Define,L,Boolean,Eat,Throwln,THrow,OpenMatch,CloseMatch,When,Stop,AND,OR,NOT;
non terminal INICIO, SENTENCIA, DECLARACION, DECLARACION_FOR, IF, IF_ELSE,
    UNTIL,FOR, SENTENCIA_BOOLEANA, SENTENCIA_FOR,LECTURA,ESCRITURA,MATCH,CASE,Identificadoroletra,METHOD,CALLMETHOD,LISTABOOL,EXP,E,T,F,PARAMETROS,PARAMETROS2;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left NOT;


start with INICIO;

INICIO ::= 

    Main Parentesis_a Parentesis_c SENTENCIA:h2 CloseMain
         {: 
           Node raiz = new Node("ROOT",false);
           Node x = new Node("MAIN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
            }
           //x.addHijo((Node)h2);
           raiz.addHijo(x);
           System.out.println(raiz.Imprimir(0)); 
          
          
          
        :} 
    |
    Main Parentesis_a Parentesis_c CloseMain|
    Main Parentesis_a Parentesis_c SENTENCIA:h2 CloseMain METHOD:h3
    {: 
           Node raiz = new Node("ROOT",false);
           
           Node x = new Node("MAIN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
            }
           //x.addHijo((Node)h2);
           raiz.addHijo(x);
           for(int i = 0;i<((Node)h3).getHijos().size();i++){
                raiz.addHijo(((Node)h3).getHijos().get(i));
            }
           
           System.out.println(raiz.Imprimir(0));
           
          
          
        :} 
    | Main Parentesis_a Parentesis_c error CloseMain 
        {: System.out.println("Main() Error CloseMain. Hay presencia de errores en el cuerpo de sentencia del main."); :}
    | error SENTENCIA CloseMain
      {: System.out.println("Error SENTENCIA CloseMain");  :} //Todo error desde el inicio hasta alguna sentencia.
                                                              //Error en la declaracion del main.
    | error CloseMain
      {: System.out.println("Error CloseMain");  :} //Todo error que venga desde el inicio hasta el CloseMain es cubierto.
                                                    //Error en la declaracion de un main vacio.
    | error
      {: System.out.println("ERROR No se reconoce la intencion ingresada.");  :} //Todo error que no se recupere
                                                                          //Unrecognized code.

    | Main error
      {: System.out.println("Main Error");  :} //Todo error que no se recupere
                                                                          //Unrecognized code.
    | {: System.out.println("No hay un codigo para analizar.");  :} //No hay codigo para

    

;





SENTENCIA ::= 
    SENTENCIA:h1 DECLARACION:h2
        {:
           
           Node x = new Node("SENTENCIA",false);
           for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
           x.addHijo((Node)h2);
           RESULT = x; 
    :}
     |
    DECLARACION:h2
        {: Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
            :}
     |
    SENTENCIA:h1 IF:h2
           {:
           Node x = new Node("SENTENCIA",false);
            for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
           x.addHijo((Node)h2);
           RESULT = x; 
    :}
     | 
    IF:h2
        {:  Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
            :}
     |
    SENTENCIA:h1 IF_ELSE:h2
            {:
                Node x = new Node("SENTENCIA",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                x.addHijo((Node)h2);
                RESULT = x; 
            :}
        
     |
    IF_ELSE:h2 
    {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :} |
    SENTENCIA:h1 UNTIL:h2
    {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
               
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    UNTIL:h2
         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
     |
    SENTENCIA:h1 FOR:h2
     {:
                Node x = new Node("SENTENCIA",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
               
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
     |
    FOR:h2
            {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    
     |
    SENTENCIA:h1 LECTURA:h2
       {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    LECTURA:h2
            {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    |
    SENTENCIA:h1 ESCRITURA:h2
               {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
            }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    ESCRITURA:h2
           {:
            Node x = new Node("SENTENCIA",false);
            
            x.addHijo((Node)h2);
            RESULT = x;
    :}
        
    |
    SENTENCIA:h1 MATCH:h2
              {:
                Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}     
    |
    MATCH:h2

         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    | SENTENCIA:h1 CALLMETHOD:h2
    {:
        Node x = new Node("SENTENCIA",false);
                 for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                }
                
                x.addHijo((Node)h2);
                RESULT = x; 
    :}
    |
    CALLMETHOD:h2

         {:
            Node x = new Node("SENTENCIA",false);
            x.addHijo((Node)h2);
            RESULT = x;
    :}
    
    
;

PARAMETROS2::= Identificadoroletra:h1{:
           Node raiz = new Node("PARAMETROS",false);
           raiz.addHijo((Node)h1);
           RESULT = raiz;
           :}

        |  Numero:h1{:
           Node raiz = new Node("PARAMETROS",false);
           Node x = new Node(h1.toString(),false);
           raiz.addHijo(x);
           RESULT = raiz;
           :}

        |
        PARAMETROS2:h1 P_coma Identificadoroletra:h2
        {:
        Node raiz = new Node("PARAMETROS",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
        
           raiz.addHijo((Node)h2);
           RESULT = raiz;
:}
    |
        PARAMETROS2:h1 P_coma Numero:h2
        {:
        Node raiz = new Node("PARAMETROS",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
           Node x = new Node(h2.toString(),false);
           raiz.addHijo(x);
           RESULT = raiz;
:}

|{:
    Node raiz = new Node("PARAMETROS",false);
    RESULT = raiz;
:}
;

PARAMETROS::=  Int Identificadoroletra:h1{:
           Node raiz = new Node("RAIZ",false);
           raiz.addHijo(new Node("INTEGER",false));
           raiz.addHijo((Node)h1);
           RESULT = raiz;
           :}
        |
        PARAMETROS:h1 P_coma Int Identificadoroletra:h2
        {:
        Node raiz = new Node("RAIZ",false);
        
        for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
        raiz.addHijo(new Node("INTEGER",false));
           raiz.addHijo((Node)h2);
           RESULT = raiz;
:}
;
EXP ::= E:e 
{: RESULT = e;  :}
;

E ::=   E:e Suma T:t {: 
        Node x = new Node("+",false);
        x.addHijo((Node)e);
        x.addHijo((Node)t);
        RESULT = x;  :}
        |
        E:e Resta T:t {: 
        Node x = new Node("-",false);
        x.addHijo((Node)e);
        x.addHijo((Node)t);
        RESULT = x;  :}
        |
        T:t{:
            RESULT = t;
        :}
        

;

T ::=  T:t Multiplicacion F:f{:
        Node x = new Node("*",false);
        x.addHijo((Node)t);
        x.addHijo((Node)f);
        RESULT = x;
        :} 
        |
        T:t Division F:f{:
        Node x = new Node("/",false);
        x.addHijo((Node)t);
        x.addHijo((Node)f);
        RESULT = x;
        :}
        |
        F:f {:
        RESULT = f;
        :}
;

F ::=   Numero:h1{:
            Node x = new Node(h1.toString(),false);
            RESULT = x;
            :}
        |
        Identificadoroletra:h1{:
        RESULT = h1;
        :}
        |Parentesis_a E:e Parentesis_c{:
            RESULT = e;
        :}
        
;


METHOD ::=
    OpenMethod Int Identificadoroletra:h1 Parentesis_a Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        Node x = new Node("INTEGER METHOD",false);
        x.addHijo((Node)h1);
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT =  raiz; 
    :}

    |
    OpenMethod Int Identificadoroletra:h1 Parentesis_a PARAMETROS:params Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        Node x = new Node("INTEGER METHOD",false);
        x.addHijo((Node)h1);
        for(int i = 0;i<((Node)params).getHijos().size();i++){
                x.addHijo(((Node)params).getHijos().get(i));
            }
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT =  raiz; 
    :}
    
    |
     METHOD:m1 OpenMethod Int Identificadoroletra:h1 Parentesis_a  Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        for(int i = 0;i<((Node)m1).getHijos().size();i++){
                raiz.addHijo(((Node)m1).getHijos().get(i));
            }
        Node x = new Node("INTEGER METHOD",false);
        x.addHijo((Node)h1);
        
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT = raiz; 
    :}
    |
    METHOD:m1 OpenMethod Int Identificadoroletra:h1 Parentesis_a PARAMETROS:params Parentesis_c SENTENCIA:h2 Return Igual Identificadoroletra:h3 P_coma CloseMethod{:
        Node raiz = new Node("Raiz",false);
        for(int i = 0;i<((Node)m1).getHijos().size();i++){
                raiz.addHijo(((Node)m1).getHijos().get(i));
            }
        Node x = new Node("INTEGER METHOD",false);
        x.addHijo((Node)h1);
        for(int i = 0;i<((Node)params).getHijos().size();i++){
                x.addHijo(((Node)params).getHijos().get(i));
            }
        Node BLOCK = new Node("BLOQUE",false);
        for(int i = 0;i<((Node)h2).getHijos().size();i++){
                BLOCK.addHijo(((Node)h2).getHijos().get(i));
            }
        x.addHijo(BLOCK);
        Node RETURN = new Node("RETURN",false);
        RETURN.addHijo((Node)h3);
        x.addHijo(RETURN);
        raiz.addHijo(x);
        RESULT = raiz; 
    :}
    
;
Identificadoroletra ::= 
    Identificador:h1
         {:  Node x = new Node(h1.toString(),false);
            
            RESULT = x;
            :}
    |
    L:h1
    {:  Node x = new Node(h1.toString(),false);
            
            RESULT = x;
            :}
;

CALLMETHOD ::=
    Identificadoroletra:h1 Parentesis_a PARAMETROS2:h2 Parentesis_c P_coma
    {:
    Node x = new Node("METHOD-CALL",true);
    x.addHijo((Node)h1);
    x.addHijo((Node)h2);
    RESULT = x;
    :}
;
DECLARACION ::= 
    //Int
    Define Identificadoroletra:h2 As Int P_coma
         {: 
        Node x = new Node("DECLARATION",false);
        Node x2 = new Node("integer",false);
        
        x.addHijo(x2);
        x.addHijo((Node)h2);
        RESULT = x;
        :} 
    |
     
     Define Identificadoroletra:h2 As Int Igual EXP:h1 P_coma
        {: 
        Node x = new Node("DECLARATION",false);
        Node x2 = new Node("integer",false);
       
        x.addHijo(x2);
        x.addHijo((Node)h2);
        x.addHijo((Node)h1);
        RESULT = x;
        :} 
    |
    Identificadoroletra:h1 Igual EXP:h2 P_coma
        {:
        Node x = new Node("ASSIGNMENT",false);
        x.addHijo((Node)h1);
        x.addHijo((Node)h2);
        RESULT = x;
        :}
    
    |
    Identificadoroletra:h1 Igual CALLMETHOD:h2
        {:
        Node x = new Node("ASSIGNMENT",false);
        x.addHijo((Node)h1);
        x.addHijo((Node)h2);
        RESULT = x;
        :}
    
    |
    
    // int array
    Define Identificadoroletra:h1 As Int Corchete_a Numero:n Corchete_c P_coma
        {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("integer array",false);
                Node x4 = new Node("["+n.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |
    // int matriz
    Define Identificadoroletra:h1 As Int Corchete_a Numero:n1 Corchete_c Corchete_a Numero:n2 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("integer matrix",false);
                Node x4 = new Node("["+n1.toString()+"]"+"["+n2.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |

   
    //Deprecated
    //Define L As Int P_coma|  
    //Define L As Int Igual Numero P_coma|
    


    //Char
    Define Identificadoroletra:h1 As Character P_coma
        {: 
            Node x = new Node("DECLARATION",false);
            Node x2 = new Node("character",false);
            x.addHijo(x2);
            x.addHijo((Node)h1);
            RESULT = x;
        :} 
    |
    Define Identificadoroletra:h1 As Character Igual Caracter:c1 P_coma
          {: 
            Node x = new Node("DECLARATION",false);
            Node x2 = new Node("character",false);
            Node x3 = new Node(c1.toString(),false);
            x.addHijo(x2);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            RESULT = x;
        :} 
    |
    
     // char array
    Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("character array",false);
                Node x4 = new Node("["+c1.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    |
    // char matriz
    Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c Corchete_a Numero:c2 Corchete_c P_coma
          {:
              
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("character matrix",false);
                Node x4 = new Node("["+c1.toString()+"]"+"["+c2.toString()+"]",false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        
        :}
    
    |


    //Deprecated
    //Define L As Character P_coma|
    //Define L As Character Igual Comillas Identificador Comillas P_coma|

    //boolean
    Define Identificadoroletra:h1 As Boolean P_coma
            {: 
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("boolean",false);
               
                x.addHijo(x2);
                x.addHijo((Node)h1);
                RESULT = x;
        :} 
    |
    Define Identificadoroletra:h1 As Boolean Igual Op_booleano:b1 P_coma
          {: 
                Node x = new Node("DECLARATION",false);
                Node x2 = new Node("boolean",false);
                
                Node x4 = new Node(b1.toString(),false);
                x.addHijo(x2);
                x.addHijo((Node)h1);
                x.addHijo(x4);
                RESULT = x;
        :} 
    
    
    //Deprecated
    //Define L As Boolean P_coma|
    //Define L As Boolean Igual Op_booleano P_coma|

    /* ERROR HANDLING BLOCK FOR DECLARATIONS*/
    | error P_coma
    {: System.out.println("error P_Coma en Declaracion de sentencia"); :} //hubo un error en la declaracion de variable.
    | error DECLARACION
    {: System.out.println("error DECLARACION en Declaracion"); :} //hubo un error en la declaracion de variable. se recupero con otra expresion
    | error IF_ELSE
    {: System.out.println("error IF_ELSE en Declaracion"); :} //hubo un error en la declaracion de variable.
    | error UNTIL
    {: System.out.println("error UNTIL en Declaracion"); :} //hubo un error en la declaracion de variable.
    | error CloseMain
    {: System.out.println("error CloseMain en Declaracion"); :} //hubo un error en la declaracion de variable.\
    | error IF
    {: System.out.println("error IF en Declaracion"); :} //hubo un error en la declaracion de variable.
    | error FOR
    {: System.out.println("error FOr en Declaracion"); :} //hubo un error en la declaracion de variable.
    |  Define Identificadoroletra As Int
        {: // System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra As Int Igual EXP
        {: System.out.println("error NO PCOMA EXP ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Identificadoroletra Igual EXP
        {: System.out.println("error NO PCOMA EXP ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    /*|  Identificadoroletra Igual CALLMETHOD
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}*/
    |  Define Identificadoroletra:h1 As Int Corchete_a Numero:n Corchete_c
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Int Corchete_a Numero:n1 Corchete_c Corchete_a Numero:n2 Corchete_c
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Character
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Character Igual Caracter:c1
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Character Corchete_a Numero:c1 Corchete_c Corchete_a Numero:c2 Corchete_c
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Boolean
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra:h1 As Boolean Igual Op_booleano:b1
        {: System.out.println("error NO PCOMA ISSUE"); 
            parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    /*|  Identificadoroletra Igual EXP
        {: System.out.println("error NO PCOMA EXP ISSUE"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"Sentencia sin PComa"));
        :}
    |  Define Identificadoroletra As
        {: System.out.println("error NO PCOMA EXP ISSUE"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"lol"));
        :}
    |  Define Identificadoroletra
        {: System.out.println("error NO PCOMA EXP ISSUE"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"lol"));
        :}*/
    /*| error Identificador
          {: System.out.println("error NO PCOMA EXP ISSUE NEW"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"lol"));
        :}
    | error As
        {: System.out.println("error NO PCOMA EXP ISSUE NEW2"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"lol"));
        :}
    | error Igual
        {: System.out.println("error NO PCOMA EXP ISSUE NEW3"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"lol"));
        :}*/
        
;


IF ::= OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then SENTENCIA:h2 CloseTest
         {: 
           Node x = new Node("TEST",false);
           Node x2 = new Node("THEN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
           }
           for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        x.addHijo(((Node)h1).getHijos().get(i));
           }
           
           x.addHijo(x2);
           RESULT = x;
            
           
        :} 

        | OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then CloseTest
            {:
            System.out.println("SENTENCIA VACIA VALIDA");
            //LEONARDO PODES AGREGAR EL ARBOL AQUI?
                return Node x = new Node("TEST",false);
            :}

     
       // Errro handler OpenTest error CloseTest
       

      |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error SENTENCIA CloseTest //if sin then
        {:
        //System.out.println("open-test con error de sentencia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF sin THEN correcto.")); 
      :}

      |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error CloseTest //If sin then y sentencia
        {:
        //System.out.println("open-test con error de sentencia-then");
        parser.syntax_error(new Symbol(sym.error,0,0,"If con sentencia-then incorrecta. No hay nada que hacer en el then.")); 
      :}

      | OpenTest Parentesis_a Parentesis_c Then SENTENCIA CloseTest  // parametros if vacios
      {:
        //System.out.println("If sin condicion"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"If con condicion vacia.")); 
      :}
      | OpenTest Parentesis_a Parentesis_c Then  CloseTest  //Parametro vacio sin sentencia.
      {:
        //System.out.println("If sin condicion y sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"If sin condicion y sentencia vacia.")); 
      :}
      
      | OpenTest Parentesis_a Parentesis_c error  CloseTest //Parametro vacio con error en then, SENTENCIA vacia
      {:
        //System.out.println("If sin condicion y sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"If sin condicion y then no localizado. SENTENCIA VACIA.")); 
      :}
      | OpenTest Parentesis_a Parentesis_c error  SENTENCIA CloseTest //Parametro vacio y con error en then pero con sentencia despues.
      {:
        //System.out.println("If sin condicion y sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"If sin condicion y then no localizado")); 
      :}
      | OpenTest  Then  CloseTest //If sin condicion ni sentencia ni parentesis
      {:
        //System.out.println("If sin condicion y sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"If sin condicion y sentencia vacia.")); 
      :}
      | OpenTest error Then SENTENCIA CloseTest //If con error en condicio.
      {:
        //System.out.println("Error en la condicion del If"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"OPENTEST ERROR THEN SENTENCIA CLOSETEST. If con error en condicion")); 
      :}
      | OpenTest error Then error CloseTest //If con error en parametros de condicion y sentencia. 
      {:
        //System.out.println("Error en la condicion del If"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"OPENTEST ERROR THEN ERROR CLOSETEST If con error en condicion y sentencia")); 
      :}
      | OpenTest error Then CloseTest //If con error en condicion sin sentencia.
      {:
        //System.out.println("Error en la condicion del If. if con sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"OPENTEST ERROR THEN CLOSETEST If con error en condicion. If con sentencia vacia")); 
      :}
      | error Then CloseTest //Possible error arising here. //If sin opentest o con error en condicion.")); 
      {:
        //System.out.println("Error en la condicion del If. if con sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"ERROR THEN CLOSETEST. No hay openmain sentencia vacia" ));
      :}
      | error Then SENTENCIA CloseTest //If sin opentest o con error en condicion. y CON sentencia.")); 
      {:
        //System.out.println("Error en la condicion del If"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"ERROR THEN SENTENCIA CLOSETEST. No open-main")); 
      :}
      
      
      
      
;


LISTABOOL ::= LISTABOOL:h1 SENTENCIA_BOOLEANA:h2{:
                    Node Raiz = new Node("raiz",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        Raiz.addHijo(((Node)h1).getHijos().get(i));
                     }
                     for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        Raiz.addHijo(((Node)h2).getHijos().get(i));
                     }
                     RESULT =Raiz;
                :}|
                SENTENCIA_BOOLEANA:h1{:
                    Node Raiz = new Node("raiz",false);
                    Raiz.addHijo((Node)h1);
                    RESULT = Raiz;
                :}
             
                
;
SENTENCIA_BOOLEANA ::= 
    
    //Esta parte hace falta ajustarla para lo de recursividad y lo de operaciones con precedencia y asociatividad
    SENTENCIA_BOOLEANA:h1 AND SENTENCIA_BOOLEANA:h2{:
                Node x = new Node("BOOLEAN SATEMENT",false);
                Node and = new Node("&",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        and.addHijo(((Node)h1).getHijos().get(i));
                     }
               
                
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        and.addHijo(((Node)h2).getHijos().get(i));
                     }
                x.addHijo(and);
                RESULT = x;
              :}
                
              |
              SENTENCIA_BOOLEANA:h1 OR SENTENCIA_BOOLEANA:h2
              {:
                Node x = new Node("BOOLEAN SATEMENT",false);
                Node or = new Node("|",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        or.addHijo(((Node)h1).getHijos().get(i));
                     }
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                        or.addHijo(((Node)h2).getHijos().get(i));
                     }
                x.addHijo(or);
                RESULT = x;
              :}
              |
            NOT SENTENCIA_BOOLEANA:h1 {:
                Node x = new Node("BOOLEAN SATEMENT",false);
                Node not = new Node("!",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        not.addHijo(((Node)h1).getHijos().get(i));
                     }
                x.addHijo(not);
                RESULT = x;
                
              :}
              |
              
    Op_booleano:h2
          {: 
            Node x = new Node("BOOLEAN SATEMENT",false);
            Node x2 = new Node(h2.toString(),false);
            x.addHijo(x2);
            RESULT = x;
           
        :} 
    |
    Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c{:
            
            RESULT = h1;
    :}
    | 
    Identificadoroletra:h1 Op_relacional:h2 Op_booleano:h3
        {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(h3.toString(),false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
     |
    Identificadoroletra:h1 Op_relacional:h2 Numero:h3
            {: 
                Node x = new Node("BOOLEAN STATEMENT",false);
                
                Node x3 = new Node(h2.toString(),false);
                Node x4 = new Node(h3.toString(),false);
                x.addHijo((Node)h1);
                x.addHijo(x3);
                x.addHijo(x4);
                RESULT = x;
           
        :} 
            
     |
    Identificadoroletra:h1 Op_relacional:h2 Identificador:h3
               {: 
                    Node x = new Node("BOOLEANA STATEMENT",false);
                    
                    Node x3 = new Node(h2.toString(),false);
                    Node x4 = new Node(h3.toString(),false);
                    x.addHijo((Node)h1);
                    x.addHijo(x3);
                    x.addHijo(x4);
                    RESULT = x;
           
        :} 
    |
    Identificadoroletra:h1 Op_relacional:h2 Comillas Comillas
        {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(" ",false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
     |
        Identificadoroletra:h1 Op_relacional:h2 Caracter:h3
          {: 
            Node x = new Node("BOOLEAN STATEMENT",false);
            
            Node x3 = new Node(h2.toString(),false);
            Node x4 = new Node(h3.toString(),false);
            x.addHijo((Node)h1);
            x.addHijo(x3);
            x.addHijo(x4);
            RESULT = x;
           
        :} 
            
;
IF_ELSE ::= OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then SENTENCIA:h2  Or SENTENCIA:h3 CloseTest 
     {: 
           Node x = new Node("TEST",false);
           Node x2 = new Node("THEN",false);
           for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
           }
            for(int i = 0;i<((Node)h1).getHijos().size();i++){
                        x.addHijo(((Node)h1).getHijos().get(i));
           }
           Node x3 = new Node("OR",false);
           for(int i = 0;i<((Node)h3).getHijos().size();i++){
                x3.addHijo(((Node)h3).getHijos().get(i));
           }
           x.addHijo(x2);
           x.addHijo(x3);
            RESULT = x;
            
           
        :} 
        ////////////////////ERROR HANDLING SECTION.
        
        | OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error SENTENCIA Or SENTENCIA CloseTest ////If else con error en then
        {:
        //System.out.println("open-test con error de sentencia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en [then].")); 
        :}

        |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error Or SENTENCIA CloseTest  ///////Error en sentencia-then
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then al inicio.")); 
        :}

        |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c error Or error CloseTest ///////Error en ambas sentencias del IF ELSE
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then al inicio y en sentencia-closetest")); 
        :}

        |OpenTest Parentesis_a LISTABOOL:h1 Parentesis_c Then Or error CloseTest  ////// Error en sentencia-closetest
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-closetest")); 
        :}
        
       
      




        | OpenTest Parentesis_a Parentesis_c Then SENTENCIA Or SENTENCIA CloseTest //IF ELSE con condicion vacia
        {:
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE sin condicion")); 
        :}

        | OpenTest Parentesis_a  Parentesis_c error SENTENCIA Or SENTENCIA CloseTest ////If else con error en then y condicion vacia
        {:
        //System.out.println("open-test con error de sentencia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en [then], y condicion vacia.")); 
        :}
        |OpenTest Parentesis_a  Parentesis_c error Or SENTENCIA CloseTest  ///////Error en sentencia-then
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then al inicio, condicion vacia.")); 
        :}
        |OpenTest Parentesis_a  Parentesis_c error Or error CloseTest ///////Error en ambas sentencias del IF ELSE
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then al inicio y en sentencia-closetest. condicion vacia.")); 
        :}
        |OpenTest Parentesis_a  Parentesis_c Then Or error CloseTest  ////// Error en sentencia-closetest
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-closetest , condicion vacia")); 
        :}
        

        




        /*| OpenTest Parentesis_a error Parentesis_c Then SENTENCIA Or SENTENCIA CloseTest // If else con error en la condicion
        {:
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en condicion")); 
        :}
        | OpenTest Parentesis_a error Parentesis_c Then SENTENCIA Or SENTENCIA CloseTest //IF ELSE con condicion vacia
        {:
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE error condicion")); 
        :}

        | OpenTest Parentesis_a error Parentesis_c error SENTENCIA Or SENTENCIA CloseTest ////If else con error en then y condicion vacia
        {:
        //System.out.println("open-test con error de sentencia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en [then], y condicion vacia.")); 
        :}
        |OpenTest Parentesis_a error  Parentesis_c error Or SENTENCIA CloseTest  ///////Error en sentencia-then
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then al inicio, condicion vacia.")); 
        :}
        |OpenTest Parentesis_a error Parentesis_c error Or error CloseTest ///////Error en ambas sentencias del IF ELSE
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then al inicio y en sentencia-closetest. condicion vacia.")); 
        :}
        |OpenTest Parentesis_a error Parentesis_c Then Or error CloseTest  ////// Error en sentencia-closetest
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-closetest , condicion vacia")); 
        :}*/



        | OpenTest Then SENTENCIA Or SENTENCIA CloseTest   // if sin parentesis
        {:
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE sin condicion ni parentesis")); 
        :}


         |OpenTest error Or error CloseTest /////// Error en sentencia then y sentencia-closetest
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then y sentencia-closetest")); 
        :}

        |OpenTest error SENTENCIA Or SENTENCIA CloseTest /////// Error en sentencia then.
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then y sentencia-closetest")); 
        :}

         |OpenTest error Or SENTENCIA CloseTest /////// Error en sentencia then y sentencia-closetest
        {:
        
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then y sentencia-closetest")); 
        :}

        

        |OpenTest error Then SENTENCIA Or SENTENCIA CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error irreconosible en la condicion.")); 
        :}

        |OpenTest error Then error Or SENTENCIA CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error irreconosible en la condicion sentencia.")); 
        :}

        |OpenTest error Or  CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error irreconosible en la condicion sentencia.")); 
        :}

        |OpenTest error Then SENTENCIA Or error CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error irreconosible en la condicion sentencia-then y en Sentencia-closetest.")); 
        :}
        
        
        |OpenTest Then Or error CloseTest /////// Error en sentencia-closetest.
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error en sentencia-then")); 
        :}

        |OpenTest error SENTENCIA Or error CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error irreconosible en la condicion sentencia-then y en Sentencia-closetest.")); 
        :}

        |OpenTest error SENTENCIA Or CloseTest /////// Error en sentencia then 
        {:
        //System.out.println("open-test con error de sentencia-then"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"IF ELSE con error irreconosible en la condicion sentencia-then. .")); 
        :}

        | error Then SENTENCIA Or CloseTest //Possible error arising here. //If sin opentest o con error en condicion.")); 
      {:
        //System.out.println("Error en la condicion del If. if con sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"ERROR THEN CLOSETEST. No hay openmain sentencia vacia" ));
      :}
      

        /*| error Then SENTENCIA Or CloseTest //Possible error arising here. //If sin opentest o con error en condicion.")); 
      {:
        //System.out.println("Error en la condicion del If. if con sentencia vacia"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"ERROR THEN CLOSETEST. No hay openmain sentencia vacia" ));
      :}
      | error Then SENTENCIA CloseTest //If sin opentest o con error en condicion. y CON sentencia.")); 
      {:
        //System.out.println("Error en la condicion del If"); 
        parser.syntax_error(new Symbol(sym.error,0,0,"ERROR THEN SENTENCIA CLOSETEST. No open-main")); 
      :}*/

      
      
    
;
UNTIL ::= OpenUntil Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c Do SENTENCIA:h2 CloseUntil
            {:
                Node x = new Node("UNTIL",false);
                x.addHijo((Node)h1);
                Node x2 = new Node("DO",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                    x2.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(x2);
                RESULT = x;

        :}

        | OpenUntil Parentesis_a SENTENCIA_BOOLEANA:h1 Parentesis_c Do  CloseUntil
            {:
            System.out.println("SENTENCIA VACIA VALIDA");
            //LEONARDO PODES AGREGAR EL ARBOL AQUI?
            :}





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         //Error Handling block OpenUntil error CloseUntil

        |OpenUntil Parentesis_a SENTENCIA_BOOLEANA Parentesis_c error SENTENCIA CloseUntil //OpenUntil sin Do
        {:
         parser.syntax_error(new Symbol(sym.error,0,0,"Open Until sin DO correcto.")); 
        :}

      |OpenUntil Parentesis_a SENTENCIA_BOOLEANA Parentesis_c error CloseUntil //OpenUnitl sin do y sentencia
        {:
        
        parser.syntax_error(new Symbol(sym.error,0,0,"OpenUntil con sentencia-do incorrecta. No hay nada que hacer en el do.")); 
      :}

      | OpenUntil Parentesis_a Parentesis_c Do SENTENCIA CloseUntil  // parametros Until vacios
      {:
        parser.syntax_error(new Symbol(sym.error,0,0,"OpenUntil con condicion vacia. .")); 
      :}
      | OpenUntil Parentesis_a Parentesis_c Do  CloseUntil  //Parametro vacio sin sentencia.
      {:
        parser.syntax_error(new Symbol(sym.error,0,0,"Until sin condicion y sentencia vacia.")); 
      :}
      
      | OpenUntil Parentesis_a Parentesis_c error  CloseUntil //Parametro vacio con error en Do, SENTENCIA vacia
      {: 
        parser.syntax_error(new Symbol(sym.error,0,0,"Until sin condicion y Do no localizado. SENTENCIA VACIA.")); 
      :}

      | OpenUntil Parentesis_a Parentesis_c error  SENTENCIA CloseUntil //Parametro vacio y con error en Do pero con sentencia despues.
      {:
        parser.syntax_error(new Symbol(sym.error,0,0,"Until sin condicion y Do no localizado")); 
      :}

      | OpenUntil Do CloseUntil //Until sin condicion ni sentencia ni parentesis
      {:
        parser.syntax_error(new Symbol(sym.error,0,0,"Until sin condicion ni sentencia ni parentesis")); 
      :}

      | OpenUntil error Do SENTENCIA CloseUntil //Until con error en condicion.
      {:
        parser.syntax_error(new Symbol(sym.error,0,0,"OPENUNTIL ERROR DO SENTENCIA CLOSEUNTIL. Until con error en condicion")); 
      :}

      | OpenUntil error Do error CloseUntil //Until con error en parametros de condicion y sentencia. 
      {:
        parser.syntax_error(new Symbol(sym.error,0,0,"OPENUNTIL ERROR DO ERROR CLOSEUNTIL con error en condicion y sentencia")); 
      :}

      | OpenUntil error Do CloseUntil //Until con error en condicion sin sentencia.
      {:
        parser.syntax_error(new Symbol(sym.error,0,0,"OPENUNTIL ERROR DO CLOSETUNTIL. Until con error en condicion. Until con sentencia vacia")); 
      :}

      | error Do CloseUntil //Possible error arising here. //Until sin openUntil o con error en condicion.")); 
      {: 
        parser.syntax_error(new Symbol(sym.error,0,0,"ERROR DO CLOSEUNTIL. No hay openuntil sentencia vacia" ));
      :}

      | error Do SENTENCIA CloseUntil//Do sin openuntil o con error en condicion. y CON sentencia.")); 
      {:        
        parser.syntax_error(new Symbol(sym.error,0,0,"ERROR Do SENTENCIA CLOSEUNTIl. No open-until")); 
      :}










;
FOR ::= OpenFor Parentesis_a SENTENCIA_FOR:h1 Parentesis_c  SENTENCIA:h2 CloseFor 
        {:
                Node x = new Node("FOR",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                x.addHijo(((Node)h1).getHijos().get(i));
                 }
           
                Node x2 = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x2.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(x2);
                RESULT = x;
        :}

            // Error Handling Block | OpenFor error CloseFor
;
SENTENCIA_FOR ::=
    Int Identificadoroletra:h1 Igual Numero:n P_coma SENTENCIA_BOOLEANA:h2 P_coma DECLARACION_FOR:h3
        {:
            Node raiz = new Node("ROOT",false);
            Node x = new Node("FOR STATEMENT",false);
            
            x.addHijo((Node)h1);
            x.addHijo(new Node(n.toString(),false));
            raiz.addHijo(x);
            raiz.addHijo((Node)h2);
            raiz.addHijo((Node)h3);
            RESULT = raiz;
        :}
     |
    Identificador Igual Numero P_coma SENTENCIA_BOOLEANA P_coma DECLARACION_FOR
;

LECTURA ::= Eat Identificadoroletra:h1 P_coma
              {:
                Node x = new Node("EAT",false);
                x.addHijo((Node)h1);
                RESULT = x;
               :}
            //Deprecation Eat L P_coma |
            //Error handling block Eat error
;
ESCRITURA ::= THrow Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROW",false);
                    x.addHijo((Node)h1);
                    RESULT = x;
               :}
             |
              Throwln Parentesis_a Identificadoroletra:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROWLN",false);
                    x.addHijo((Node)h1);
                    RESULT = x;
               :} 
                |
               Throwln Parentesis_a SENTENCIA:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROWLN",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                            x.addHijo(((Node)h1).getHijos().get(i));
                        }
                    RESULT = x;
               :}
               |THrow Parentesis_a SENTENCIA:h1 Parentesis_c P_coma
                {:
                    Node x = new Node("THROW",false);
                    for(int i = 0;i<((Node)h1).getHijos().size();i++){
                            x.addHijo(((Node)h1).getHijos().get(i));
                        }
                    RESULT = x;
               :}
              //Error handling block THrow error | Throwln error
              //Posible validacion de throw strings strings.
;
DECLARACION_FOR ::= 
    Identificadoroletra:h1 Op_atribucion:h2 EXP:h3
    {:
        Node x = new Node("FOR DECLARATION",false);
        x.addHijo((Node)h1);
        x.addHijo(new Node(h2.toString(),false));
        x.addHijo((Node)h3);
        RESULT = x;
    :}
     |
    Identificadoroletra:h1 Op_incremento:h2
            {:
                Node x = new Node("FOR DECLARATION",false);
                x.addHijo((Node)h1);
                x.addHijo(new Node(h2.toString(),false));
                RESULT = x;
    :}
     | 
    Op_incremento:h2 Identificadoroletra:h1
         {:
                Node x = new Node("FOR DECLARATION",false);
                x.addHijo((Node)h1);
                x.addHijo(new Node(h2.toString(),false));
                RESULT = x;
    :}
;

MATCH ::= 
    OpenMatch Parentesis_a Identificadoroletra:h1 Parentesis_c CASE:h2 CloseMatch 
    {:
          Node x = new Node("OPENMATCH",false);
          x.addHijo((Node)h1);
          for(int i = 0;i<((Node)h2).getHijos().size();i++){
                x.addHijo(((Node)h2).getHijos().get(i));
           }
          RESULT = x;
    :}
    //Error Handling Block|OpenMatch Parentesis_a Identificador Parentesis_c error CloseMatch
    
;

CASE ::=
    //Might need some modification later
    CASE:h1 When Caracter:h2 Igual SENTENCIA:h3 Stop P_coma
            {:
                
                Node raiz = new Node("ROOT",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
                Node x = new Node("CHAR-CASE",false);
                x.addHijo(new Node((h2.toString()).substring(1,2),false));
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h3).getHijos().size();i++){
                THEN.addHijo(((Node)h3).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
    When Caracter:h1 Igual SENTENCIA:h2 Stop P_coma

       {:
                Node raiz = new Node("ROOT",false);
                Node x = new Node("CHAR-CASE",false);
                x.addHijo(new Node((h1.toString()).substring(1,2),false));
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                THEN.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
      CASE:h1 When Identificadoroletra:h2 Igual SENTENCIA:h3 Stop P_coma
            {:
                
                Node raiz = new Node("ROOT",false);
                for(int i = 0;i<((Node)h1).getHijos().size();i++){
                raiz.addHijo(((Node)h1).getHijos().get(i));
                }
                Node x = new Node("CASE",false);
                x.addHijo((Node)h2);
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h3).getHijos().size();i++){
                THEN.addHijo(((Node)h3).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
    |
     When Identificadoroletra:h1 Igual SENTENCIA:h2 Stop P_coma

       {:
                Node raiz = new Node("Raiz",false);
                Node x = new Node("CASE",false);
                x.addHijo((Node)h1);
                Node THEN = new Node("THEN",false);
                for(int i = 0;i<((Node)h2).getHijos().size();i++){
                THEN.addHijo(((Node)h2).getHijos().get(i));
                }
                x.addHijo(THEN);
                raiz.addHijo(x);
                RESULT = raiz;
    :}
;